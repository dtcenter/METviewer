setwd("#<r_work>#");

source("include/util_plot.R");
source("include/boxplot_ci.R");



strDataFile = "#<data_file>#";
strPlotFile = "#<plot_file>#";

options(scipen=10);

#
#  Plot Control Variables
#

boolGridOn		= #<grid_on>#;
boolLogY1		= #<log_y1>#;
boolLogY2		= #<log_y2>#;
boolEqualizeByIndep = #<equalize_by_indep>#;
boolEventEqual	= #<event_equal>#;
boolBoxAvg		= #<box_avg>#;
boolBoxPts		= #<box_pts>#;
boolShowNStats	= #<show_nstats>#;
boolDumpPoints1  = #<dump_points1>#;
boolDumpPoints2  = #<dump_points2>#;

listY1limUsr	= #<y1_lim>#;
listY2limUsr	= #<y2_lim>#;
		

strIndyVar = "#<indy_var>#";

listDep1Plot = #<dep1_plot>#;

listDep2Plot = #<dep2_plot>#;
		
listAggVal = #<agg_list>#;
		
listSeries1Val = #<series1_list>#;

listSeries2Val = #<series2_list>#;

listFixedValEx = #<fix_val_list_eq>#;

listSeriesNobs = #<series_nobs>#;
		
listDep1Scale = #<dep1_scale>#;

listDep2Scale = #<dep2_scale>#;

listIndy = #<indy_list>#;

listPlotDisp = #<plot_disp>#;

listColors = #<colors>#;

listPch = #<pch>#;

listPlotOrderSeries	= #<order_series>#;

listDiffSeries1=#<series1_diff_list>#;

listDiffSeries2=#<series2_diff_list>#;

listLegendUsr = #<legend>#;

listSeries1Var = names(listSeries1Val);
listSeries2Var = names(listSeries2Val);
box_outline = #<box_outline>#;
boolXReverse  = #<x_reverse>#;


#if fcst_var is a spetial char - read it as-is and do not convert
sampleData = read.delim(strDataFile,nrows=5);
classes <- sapply(sampleData, class);
numeric_columns <- c('stat_value', 'stat_bcl', 'stat_bcu', 'stat_ncu', 'stat_ncl','fbs', 'fss');
integer_columns <- c('fcst_lead','nstats');
character_columns <- c('fcst_var', 'model', 'stat_name')
for(col in 1:ncol(sampleData)){
  if ( is.element( names(classes)[col] , numeric_columns) ){
    classes[col]='numeric';
  } else if ( is.element( names(classes)[col] , integer_columns) ){
    classes[col]='integer';
  } else if ( is.element( names(classes)[col] , character_columns) ){
    classes[col]='character';
  }
}
dfPlot = read.delim(strDataFile,colClasses = classes);

# run event equalizer, if requested
if( FALSE != boolEventEqual  ){

  dfPlot1 = data.frame();
   #list all fixed variables
   listFixVars=c();
   listFixVarVals = c();
   if(length(listFixedValEx) > 0){
     for(index in 1:length(listFixedValEx)){
       if(is.null(listFixVars)){
        listFixVars = names(listFixedValEx[index]);
        listFixVarVals = permute(listFixedValEx[index]);
       }else{
        listFixVars =  append(listFixVars, names(listFixedValEx[index]));
        listFixVarVals = append(listFixVarVals, permute(listFixedValEx[index]));
       }
     }
   }
  for( strDep1Name in names(listDep1Plot) ){
    for( strDep1Stat in listDep1Plot[[strDep1Name]] ){
      fPlot = dfPlot;
            for(strSeriesVal in names(listSeries1Val)){
              vectValPerms = c();
              for(index in 1:length(listSeries1Val[[strSeriesVal]])){
                vectValPerms= append(vectValPerms, strsplit(listSeries1Val[[strSeriesVal]][index], ",")[[1]]);
              }
              fPlot = fPlot[fPlot$fcst_var == strDep1Name & fPlot[[strSeriesVal]] %in% vectValPerms & fPlot$stat_name %in% strDep1Stat,  ];

            }
            fPlot = eventEqualize(fPlot, strIndyVar, listIndy, listSeries1Val, listFixVars,listFixVarVals, boolEqualizeByIndep, FALSE);
            dfPlot1 = rbind(dfPlot1, fPlot);
     }
   }

  #if the second Y axis is present - run event equalizer on Y1
  # and then run event equalizer on Y1 and Y2 equalized data
  if(length(listSeries2Val) > 0){
    dfPlot2 = data.frame();
    for( strDep2Name in names(listDep2Plot) ){
      for( strDep2Stat in listDep2Plot[[strDep2Name]] ){
        fPlot = dfPlot;
                 for(strSeriesVal in names(listSeries2Val)){
                   vectValPerms = c();
                   for(index in 1:length(listSeries2Val[[strSeriesVal]])){
                     vectValPerms= append(vectValPerms, strsplit(listSeries2Val[[strSeriesVal]][index], ",")[[1]]);
                   }
                   fPlot = fPlot[dPlot$fcst_var == strDep1Name & fPlot[[strSeriesVal]] %in% vectValPerms & fPlot$stat_name %in% strDep2Stat,  ];

                 }
                 fPlot = eventEqualize(fPlot, strIndyVar, listIndy, listSeries2Val, listFixVars,listFixVarVals, boolEqualizeByIndep, FALSE);
                 dfPlot1 = rbind(dfPlot2, fPlot);
      }
    }
    dfPlot = rbind(dfPlot1, dfPlot2);
    listSeriesVal=list();
    for( seriesVal in names(listSeries1Val) ){
      listSeriesVal[[seriesVal]] = append(listSeries1Val[[seriesVal]], listSeries2Val[[seriesVal]]);
    }
    listSeriesVal$model = append(listSeries1Val$model,listSeries2Val$model)
    dfPlot = eventEqualize(dfPlot, strIndyVar, listIndy, listSeriesVal, listFixVars,listFixVarVals,boolEqualizeByIndep, TRUE);
  }else{
    dfPlot = dfPlot1;
  }
strAfrerEqualizeFile = sub("\\.data$", ".dataAfterEq", strDataFile, perl=TRUE);
write.table(dfPlot, file=strAfrerEqualizeFile, quote=FALSE, row.names=FALSE, col.names=TRUE, sep = "\t");

}



listColorsOrdered=c();
listPlotDispOrdered=c();
for(index in 1:length(listPlotOrderSeries)){
  listColorsOrdered[ listPlotOrderSeries[index] ]=listColors[index];
  listPlotDispOrdered[ listPlotOrderSeries[index] ]=listPlotDisp[index];
}

#order legends
if( 0 < length(listLegendUsr) ){
  listLegendUsrOrdered=c();
  for(index in 1:length(listPlotOrderSeries)){
    listLegendUsrOrdered[ listPlotOrderSeries[index] ]=listLegendUsr[index];
  }
}



# build the y1 plot series using information in the plot dataframe
intNumSeries1 = numSeries(listSeries1Val, listDep1Plot);
intNumSeries1Diff = length(listDiffSeries1);
intNumSeries1Dep = nrow( permute(listSeries1Val) );


intNumSeries2=0;
intNumSeries2Dep=0;
intNumSeries2Diff=0;
if( 0 < length(listDep2Plot) ){
  # calculate the number of y2 series per dep stat
  intNumSeries2 = numSeries(listSeries2Val, listDep2Plot);
  intNumSeries2Diff = length(listDiffSeries2);
  intNumSeries2Dep = nrow( permute(listSeries2Val) );
}




# build the display lists for y1 and y2
indexesNumSeries1 = 1:intNumSeries1;
listPlotDispSeries1 = listPlotDisp[indexesNumSeries1];
listPchSeries1 = listPch[indexesNumSeries1];
listColorsSeries1 = listColors[indexesNumSeries1];
listPlotOrderSeries1Orig = listPlotOrderSeries[indexesNumSeries1];
if(intNumSeries2 > 0){
  indexesNumSeries2 = (intNumSeries1+1):(intNumSeries1+intNumSeries2);
  listPlotDispSeries2 = listPlotDisp[indexesNumSeries2];
  listPlotOrderSeries2Orig = listPlotOrderSeries[indexesNumSeries2];
  listColorsSeries2 = listColors[indexesNumSeries2];
  listPchSeries2 = listPch[indexesNumSeries2];
}else{
  listPlotDisp2=list();
  listPlotOrderSeries2=list();
  listColors2=list();
  listPch2 = list();
}
if(intNumSeries1Diff > 0){
  indexesNumSeries1Diff = (intNumSeries1+intNumSeries2 +1):(intNumSeries1+intNumSeries2 + intNumSeries1Diff);
  listPlotOrderSeries1Orig = append(listPlotOrderSeries1Orig,listPlotOrderSeries[indexesNumSeries1Diff]);
  listPlotDispSeries1 = append(listPlotDispSeries1,listPlotDisp[indexesNumSeries1Diff]);
  listColorsSeries1 = append (listColorsSeries1,  listColors[indexesNumSeries1Diff]);
  listPchSeries1 = append (listPchSeries1,  listPch[indexesNumSeries1Diff]);
}
if(intNumSeries2Diff > 0 ){
  indexesNumSeries2Diff = (intNumSeries1+intNumSeries2 + intNumSeries1Diff +1):length(listPlotDisp);
  listPlotOrderSeries2Orig = append(listPlotOrderSeries2Orig,listPlotOrderSeries[indexesNumSeries2Diff]);
  listPlotDispSeries2 = append(listPlotDispSeries2,listPlotDisp[indexesNumSeries2Diff]);
  listColorsSeries2 = append (listColorsSeries2,  listColors[indexesNumSeries2Diff]);
  listPchSeries2 = append (listPchSeries2,  listPch[indexesNumSeries2Diff]);
}



# build the series value permutations
matPermVal1 = permute(listSeries1Val);
if(intNumSeries2 > 0){
  matPermVal2 = permute(listSeries2Val);
}

# calculate the horizonal location increment
dblIndySpan = .75 * ( sum(listPlotDisp) ) * #<box_boxwex>#;
dblInc = 0;
if( 1 < ( sum(listPlotDisp) ) ){
  dblInc = dblIndySpan / (( sum(listPlotDisp) ) - 1);
} else {
  dblIndySpan = 0;
}
listX = 1:length(listIndy);
if( TRUE == boolXReverse ){
  listX = rev(listX)
}
listXMinMax = c(min(listX)-1, max(listX)+1);






#separate dfPlot to Y1 and Y2
dfPlot1 = data.frame();
dfPlot2 = data.frame();
if(length(listSeries2Val) > 0){
  for( strDep1Name in names(listDep1Plot) ){
    for( strDep1Stat in listDep1Plot[[strDep1Name]] ){
      for(strSeriesVal in names(listSeries1Val)){
        fPlot = dfPlot[dfPlot$fcst_var == strDep1Name & dfPlot[[strSeriesVal]] %in% listSeries1Val[[strSeriesVal]] & dfPlot$stat_name %in% strDep1Stat,  ];
        dfPlot1 = rbind(dfPlot1, fPlot);
      }
    }
  }
  for( strDep2Name in names(listDep2Plot) ){
    for( strDep2Stat in listDep2Plot[[strDep2Name]] ){
      for(strSeriesVal in names(listSeries2Val)){
        fPlot = dfPlot[dfPlot$fcst_var == strDep2Name & dfPlot[[strSeriesVal]] %in% listSeries2Val[[strSeriesVal]] & dfPlot$stat_name %in% strDep2Stat,  ];
        dfPlot2 = rbind(dfPlot2, fPlot);
      }
    }
  }
}else{
  dfPlot1 = dfPlot;
}

# if log scale prepare the data and boxplot parameters
strLogParm1 = "";
strLogParm2 = "";
if( boolLogY1 ){
  if( 0 < nrow(dfPlot1[dfPlot1$stat_value == 0,]) ){ dfPlot1[dfPlot1$stat_value == 0,]$stat_value = NA; }
  strLogParm1 = "y";
}

if( boolLogY2 && length(dfPlot2) > 0){
  if( 0 < nrow(dfPlot2[dfPlot2$stat_value == 0,]) ){ dfPlot2[dfPlot2$stat_value == 0,]$stat_value = NA; }
  strLogParm2 = "y";
}



# if the plot contains points, establish the plot window and y axis
listY1lim = c();
listY2lim = c();

listNStats=rep(0, length(listIndy))

# build a box series Y1 for each plot series permutation
listBoxes1 = list();
listMeans1 = list();
listAllStats1=list();
listBoxes2 = list();
listMeans2 = list();
listAllStats2=list();

ll=list();
revision_stats = c();

for( strDep1Name in names(listDep1Plot) ){
  for( strDep1Stat in listDep1Plot[[strDep1Name]] ){

    dfPlotStat = dfPlot[dfPlot$fcst_var == strDep1Name & dfPlot$stat_name == strDep1Stat,];
    dfPlotStat = scaleStats(dfPlotStat, listDep1Scale, paste(strDep1Name, "_", strDep1Stat, sep=""));

    listAllStats = buildAllStats(dfPlotStat, listSeries1Val,strDep1Stat,strDep1Name);
    ll = append(ll, listAllStats);
  }
}

for( listAllStatsName in names(ll) ){
  allStatsArr = strsplit(listAllStatsName, " ")[[1]]
  fcst_var = allStatsArr[length(allStatsArr)-1]
  listBox = list();
  for(strIndy in listIndy){
    listBox[[ strIndy ]] = ll[[listAllStatsName]][ ll[[listAllStatsName]][[strIndyVar]] == strIndy, ]$stat_value;
  }
  if (grepl("^REV_", fcst_var)){
      used_names <- names(ll[[listAllStatsName]]) %in% c("stat_value", "revision_id")
      stats = calculateMtdRevisionStats(ll[[listAllStatsName]][used_names]);
      ww_run_title = paste("WW Runs Test:", stats$ww_run, sep = " ");
      ac_test_title = paste("Auto-Corr Test: p=", stats$auto_cor_p, ",r=", stats$auto_cor_r, sep = " ");
      listAllStatsName = paste(listAllStatsName,  " (");
      listAllStatsName = paste(listAllStatsName, ww_run_title, " ");
      listAllStatsName = paste(listAllStatsName, ac_test_title, " ");
      listAllStatsName = paste(listAllStatsName,  ")");
      cat('\n', listAllStatsName, '\n');
      revision_stats[[length(revision_stats)+1]] <- stats;
  }
  if ( strDep1Stat == 'DMAP_GBETA'){
        unique_beta_value = unique(ll[[listAllStatsName]][c('beta_value')])
        if (nrow(unique_beta_value) > 1){
          cat("\n  WARNING: note that beta_value differs for one or more GBETA values for ",listAllStatsName,", so that comparisons across cases may not be comparable.\n");
        }
     }
  listAllStats1[[listAllStatsName]] = listBox;
}

#add Y1 DIFF series - if exist
if(length(listDiffSeries1) > 0){
  for( diffSeries1Name in 1: length(listDiffSeries1) ){ #1,2....
   #get  names of DIFF series
    diffSeriesVec = listDiffSeries1[[diffSeries1Name]];
    derivedCurveName = getDerivedCurveName(diffSeriesVec);

    listBox1 = listAllStats1[[ diffSeriesVec[1] ]];
    listBox2 = listAllStats1[[ diffSeriesVec[2] ]];
    listBoxDiff = list();
    listFields = names(listBox1);
    for (strIndy in listIndy) {
      if ("fcst_valid_beg" %in% listFields) {
        uniqueDates = nrow(unique(listBox1[c("fcst_valid_beg", "fcst_lead", "stat_name")]))
      } else if ("fcst_valid" %in% listFields) {
        uniqueDates = nrow(unique(listBox1[c("fcst_valid", "fcst_lead", "stat_name")]))
      } else if ("fcst_init_beg" %in% listFields) {
        uniqueDates = nrow(unique(listBox1[c("fcst_init_beg", "fcst_lead", "stat_name")]))
      } else {
        uniqueDates = nrow(unique(listBox1[c("fcst_init", "fcst_lead", "stat_name")]))
      }
      if (!is.null(uniqueDates) && nrow(listBox1) != uniqueDates) {
        stop("Derived curve can't be calculated. Multiple values for one valid date/fcst_lead")
      }

      #sort data
      if ("fcst_valid_beg" %in% listFields) {
        listBox1 = listBox1[order(listBox1$fcst_valid_beg, listBox1$fcst_lead, listBox1$stat_name),];
        listBox2 = listBox2[order(listBox2$fcst_valid_beg, listBox2$fcst_lead, listBox2$stat_name),];
      }
      if ("fcst_valid" %in% listFields) {
        listBox1 = listBox1[order(listBox1$fcst_valid, listBox1$fcst_lead, listBox1$stat_name),];
        listBox2 = listBox2[order(listBox2$fcst_valid, listBox2$fcst_lead, listBox2$stat_name),];
      }
      if ("fcst_init_beg" %in% listFields) {
        listBox1 = listBox1[order(listBox1$fcst_init_beg, listBox1$fcst_lead, listBox1$stat_name),];
        listBox2 = listBox2[order(listBox2$fcst_init_beg, listBox2$fcst_lead, listBox2$stat_name),];
      }
      if ("fcst_init" %in% listFields) {
        listBox1 = listBox1[order(listBox1$fcst_init, listBox1$fcst_lead, listBox1$stat_name),];
        listBox2 = listBox2[order(listBox2$fcst_init, listBox2$fcst_lead, listBox2$stat_name),];
      }

      listBoxDiff[[strIndy]] = calcDerivedCurveValue(listBox1[[strIndy]], listBox2[[strIndy]], derivedCurveName);
    }
    listAllStats1[[derivedCurveName]] = listBoxDiff;

  }
}

# build a box series Y2 for each plot series permutation
ll=list();

for( strDep1Name in names(listDep2Plot) ){
  for( strDep2Stat in listDep2Plot[[strDep2Name]] ){

    dfPlotStat = dfPlot[dfPlot$fcst_var == strDep1Name & dfPlot$stat_name == strDep2Stat,];
    dfPlotStat = scaleStats(dfPlotStat, listDep2Scale, paste(strDep2Name, "_", strDep2Stat, sep=""));

    listAllStats = buildAllStats(dfPlotStat, listSeries2Val,strDep2Stat,strDep2Name);
    ll = append(ll, listAllStats);
  }
}

for( listAllStatsName in names(ll) ){
  allStatsArr = strsplit(listAllStatsName, " ")[[1]]
  fcst_var = allStatsArr[length(allStatsArr)-1]
  listBox = list();
  for(strIndy in listIndy){
    listBox[[ strIndy ]] = ll[[listAllStatsName]][ ll[[listAllStatsName]][[strIndyVar]] == strIndy, ]$stat_value;
  }
  if (grepl("^REV_", fcst_var)){
      used_names <- names(ll[[listAllStatsName]]) %in% c("stat_value", "revision_id")
      stats = calculateMtdRevisionStats(ll[[listAllStatsName]][used_names]);
      ww_run_title = paste("WW Runs Test:", stats$ww_run, sep = " ");
      ac_test_title = paste("Auto-Corr Test: p=", stats$auto_cor_p, ",r=", stats$auto_cor_r, sep = " ");
      listAllStatsName = paste(listAllStatsName,  " (");
      listAllStatsName = paste(listAllStatsName, ww_run_title, " ");
      listAllStatsName = paste(listAllStatsName, ac_test_title, " ");
      listAllStatsName = paste(listAllStatsName,  ")");
      cat('\n', listAllStatsName, '\n');
      revision_stats[[length(revision_stats)+1]] <- stats;
  }
  if ( strDep2Stat == 'DMAP_GBETA'){
          unique_beta_value = unique(ll[[listAllStatsName]][c('beta_value')])
          if (nrow(unique_beta_value) > 1){
            cat("\n  WARNING: note that beta_value differs for one or more GBETA values for ",listAllStatsName,", so that comparisons across cases may not be comparable.\n");
          }
       }
  listAllStats2[[listAllStatsName]] = listBox;
}
#add Y2 DIFF series - if exist
if(length(listDiffSeries2) > 0){
  for( diffSeries2Name in 1: length(listDiffSeries2) ){ #1,2....
    diffSeriesVec = listDiffSeries2[[diffSeries2Name]];
    derivedCurveName = getDerivedCurveName(diffSeriesVec);

    listBox1 = listAllStats2[[ diffSeriesVec[1] ]];
    listBox2 = listAllStats2[[ diffSeriesVec[2] ]];
    listBoxDiff = list();
    listFields = names(listBox1);

    for (strIndy in listIndy) {
      if ("fcst_valid_beg" %in% listFields) {
        uniqueDates = nrow(unique(listBox1[c("fcst_valid_beg", "fcst_lead", "stat_name")]))
      } else if ("fcst_valid" %in% listFields) {
        uniqueDates = nrow(unique(listBox1[c("fcst_valid", "fcst_lead", "stat_name")]))
      } else if ("fcst_init_beg" %in% listFields) {
        uniqueDates = nrow(unique(listBox1[c("fcst_init_beg", "fcst_lead", "stat_name")]))
      } else {
        uniqueDates = nrow(unique(listBox1[c("fcst_init", "fcst_lead", "stat_name")]))
      }
      if (nrow(listBox1) != uniqueDates) {
        stop("Derived curve can't be calculated. Multiple values for one valid date/fcst_lead")
      }

      #sort data
      if ("fcst_valid_beg" %in% listFields) {
        listBox1 = listBox1[order(listBox1$fcst_valid_beg, listBox1$fcst_lead, listBox1$stat_name),];
        listBox2 = listBox2[order(listBox2$fcst_valid_beg, listBox2$fcst_lead, listBox2$stat_name),];
      }
      if ("fcst_valid" %in% listFields) {
        listBox1 = listBox1[order(listBox1$fcst_valid, listBox1$fcst_lead, listBox1$stat_name),];
        listBox2 = listBox2[order(listBox2$fcst_valid, listBox2$fcst_lead, listBox2$stat_name),];
      }
      if ("fcst_init_beg" %in% listFields) {
        listBox1 = listBox1[order(listBox1$fcst_init_beg, listBox1$fcst_lead, listBox1$stat_name),];
        listBox2 = listBox2[order(listBox2$fcst_init_beg, listBox2$fcst_lead, listBox2$stat_name),];
      }
      if ("fcst_init" %in% listFields) {
        listBox1 = listBox1[order(listBox1$fcst_init, listBox1$fcst_lead, listBox1$stat_name),];
        listBox2 = listBox2[order(listBox2$fcst_init, listBox2$fcst_lead, listBox2$stat_name),];
      }
      listBoxDiff[[strIndy]] = calcDerivedCurveValue(listBox1[[strIndy]], listBox2[[strIndy]], derivedCurveName);
    }
    listAllStats2[[derivedCurveName]] = listBoxDiff;
  }
}

for( listAllStatsName in names(listAllStats1) ){
  listBox = listAllStats1[[listAllStatsName]]
  listNStatsFcstVar = c();
  for(strIndy in listIndy){
    listNStatsFcstVar = append(listNStatsFcstVar, length(listBox[[ strIndy ]]));
  }
  listNStats = listNStats +listNStatsFcstVar;

  # save the current list of series values for plotting
  intBoxesLen = length(listBoxes1);
  listBoxes1[[ intBoxesLen + 1 ]] = listBox;
  
  

  
  # if the box mean is activated, add them to the plot
  if( boolBoxAvg ){
    listMean = c();
    for(strIndy in names(listBox)){
      listMeanVal = listBox[[strIndy]];
      listMeanVal[is.na(listMeanVal)] = 0;
      listMean[length(listMean) + 1] = mean(listMeanVal);
    }
    listMeans1[[ length(listMeans1) + 1 ]] = listMean;
  }
  

}


for( listAllStatsName in names(listAllStats2) ){
  listBox = listAllStats2[[listAllStatsName]]
  listNStatsFcstVar = c();
  for(strIndy in listIndy){
    listNStatsFcstVar = append(listNStatsFcstVar, length(listBox[[ strIndy ]]));
  }
  listNStats = listNStats +listNStatsFcstVar;

  # save the current list of series values for plotting
  intBoxesLen = length(listBoxes2);
  listBoxes2[[ intBoxesLen + 1 ]] = listBox;
  
  

  
  # if the box mean is activated, add them to the plot
  if( boolBoxAvg ){
    listMean = c();
    for(strIndy in names(listBox)){
      listMeanVal = listBox[[strIndy]];
      listMeanVal[is.na(listMeanVal)] = 0;
      listMean[length(listMean) + 1] = mean(listMeanVal);
    }
    listMeans2[[ length(listMeans2) + 1 ]] = listMean;
  }
}

# specify the output file
strPlotType = "#<plot_type>#";
if( "jpeg" == strPlotType ){
  jpeg(
    strPlotFile,			# output file name, with appropriate extension
		width=#<plot_width>#,	# width of the display region, in specified units
		height=#<plot_height>#,	# height of the display region, in specified units
		res=#<plot_res>#,		# resolution, in dots per inch
		units="#<plot_units>#",	# units for height and width
    pointsize = 12,
    quality = 100,
    #bg = "white",
    #type = c("cairo", "Xlib", "quartz"),
    #antialias
  );
} else {
  bitmap(
    strPlotFile,			# output file name, with appropriate extension
		type="#<plot_type>#",	# type of bitmap
		width=#<plot_width>#,	# width of the display region, in specified units
		height=#<plot_height>#,	# height of the display region, in specified units
		res=#<plot_res>#,		# resolution, in dots per inch
		units="#<plot_units>#",	# units for height and width
    taa=4,					# bits of anti-aliasing for graphics
    gaa=4					# bits of anti-aliasing for text
  );
}

# specify plot window formatting
par(
	mar=#<mar>#,			# lines of margin in form c(bottom, left, top, right)
	mgp=#<mgp>#,			# margin line for axis title, axis labels and axis line in form c(title, labels, line)
	cex=#<cex>#,			# magnification for plot text
  las=0 					# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
);

par( new=FALSE);
boolAdd=FALSE;

if( boolBoxPts == TRUE){
  
  # determine the min and max data values
  if( 2 != length(listY1limUsr) ){
    listY1lim = c(min(dfPlot1$stat_value), max(dfPlot1$stat_value));
  } else {
    listY1lim = listY1limUsr;
  }
  
  # create the plot window
  plot(
    listX,					# series x data
    rep(0, length(listX)),	# series y1 data
    type="n",				# series line type - p: points, l: lines, o: overplotted points and lines,  
    #   b or c: points joined by lines, s or S: stair steps, h: histogram, n: nothing 
    xaxt="n",				# x-axis type - n: no axis, s: compatibility with l and t
    xaxs="r",				# x-axis style - r: regular, i: internal
    yaxt="n",				# y1-axis type - n: no axis, s: compatibility with l and t
    yaxs="r",				# x-axis style - r: regular, i: internal
    ylim=listY1lim,			# y1-axis limits
    xlab="",				# x-axis label
    ylab="",				# y1-axis label
    lwd=1,					# line width
    cex.lab=1,				# relative axis label magnification
    cex.main=1,				# relative title magnification
    cex.sub=1,				# relative subtitle magnification
    fg="gray"
  );
  
  # if y-axis log scale is enabled, set up the axis formatting
  if( boolLogY1 == TRUE){
    listY1lim = c( 10^floor(log10(listY1lim[1])), 10^ceiling(log10(listY1lim[2])) );
    par( ylog=TRUE, usr=c(par()$usr[1:2], log10(listY1lim[1]), log10(listY1lim[2])), 
         yaxp=c(listY1lim[1:2], 2) );
        
  }
}

# update the y1-axis limits to fit the data, depending on user-specification
dblMin=NULL;
dblMax=NULL;
if( 2 != length(listY1limUsr) ){

  listAllStats1List = unlist(listAllStats1);
  if(box_outline == TRUE){
    dblMin = min(listAllStats1List);
    dblMax = max(listAllStats1List);
  }else{
    for(intPermIndex in 1:length(listBoxes1)){
      listBox = listBoxes1[[intPermIndex]];
      for(boxNames in names(listBox) ){
        box = listBox[[boxNames]];
        outliers = boxplot.stats_ci(box)$out;
        listNoOutliers = box [! box %in% outliers];
        dblMinCurrent = min(listNoOutliers, na.rm = TRUE);
        dblMaxCurrent = max(listNoOutliers, na.rm = TRUE);
        if (is.null(dblMin) || dblMin > dblMinCurrent) dblMin=dblMinCurrent;
        if (is.null(dblMax) || dblMax < dblMaxCurrent) dblMax=dblMaxCurrent;
      }
    }
  }
  if( 2 != length(listY1lim) ){
    listY1lim = c(dblMin, dblMax);
  } else {
    if( dblMin < listY1lim[1] ){ listY1lim = c(dblMin, listY1lim[2]); }
    if( dblMax > listY1lim[2] ){ listY1lim = c(listY1lim[1], dblMax); }
  }
} else {
  listY1lim = listY1limUsr;
}

# update the y2-axis limits to fit the data, depending on user-specification
dblMin=NULL;
dblMax=NULL;
if( 2 != length(listY2limUsr) ){
  if(length(unlist(listAllStats2)) > 0){

    listAllStats2List = unlist(listAllStats2);
    if(box_outline == TRUE){
      dblMin = min(listAllStats2List);
      dblMax = max(listAllStats2List);
    }else{
      for(intPermIndex in 1:length(listBoxes2)){
        listBox = listBoxes2[[intPermIndex]];
        for(boxNames in names(listBox) ){
          box = listBox[[boxNames]];
          outliers = boxplot.stats_ci(box)$out;
          listNoOutliers = box [! box %in% outliers];
          dblMinCurrent = min(listNoOutliers, na.rm = TRUE);
          dblMaxCurrent = max(listNoOutliers, na.rm = TRUE);
          if (is.null(dblMin) || dblMin > dblMinCurrent) dblMin=dblMinCurrent;
          if (is.null(dblMax) || dblMax < dblMaxCurrent) dblMax=dblMaxCurrent;
        }
      }
    }
    if( 2 != length(listY2lim) ){
      listY2lim = c(dblMin, dblMax);
    } else {
      if( dblMin < listY2lim[1] ){ listY2lim = c(dblMin, listY2lim[2]); }
      if( dblMax > listY2lim[2] ){ listY2lim = c(listY2lim[1], dblMax); }
    }
  }else{
    listY2lim = listY1lim;
  }
} else {
  listY2lim = listY2limUsr;
}

# plot the series1 data

for(intPermIndex in 1:length(listBoxes1)){
  
  intPermIndexReal = listPlotOrderSeries1Orig[intPermIndex];
  
  # skip the current box, if requested
  if( FALSE == listPlotDispSeries1[intPermIndex] ){ 
    next;
  }
  
  # gather the information for the current box
  listAt = listX - (dblIndySpan/2) + (intPermIndexReal - 1) * dblInc;
  strColor = listColorsSeries1[intPermIndex];
  listBox = listBoxes1[[intPermIndex]];
  
  
  # if only points are displayed, call the points() function
  if( boolBoxPts == TRUE){
    intPch = listPchSeries1[intPermIndex];
    intIndy = 1;
    for(strIndy in names(listBox)){
      listPts = listBox[[strIndy]];
      listPtsAt = rep(listAt[intIndy], length(listPts));
      points(
        listPtsAt,	 		# x coordinate vector
        listPts,			# y coordinate vector
        type="p",			# type of plot - p: points
        pch=intPch,			# point symbol - see example(points)
        col=strColor		# point color
      );
      intIndy = intIndy + 1;
    }
  }
  
  # otherwise, call the boxplot_ci() function to build the series of boxes
  else {
    if (boolAdd != TRUE){strYaxt="s";}
    else{strYaxt="n";}
    if(TRUE == boolXReverse){
          listAt = rev(listAt);
          listBox = rev(listBox);
    }
    boxes1=boxplot_ci(
      listBox,				# box data as a list of vectors
      at=listAt,				# vector of box positions
      notch=#<box_notch>#,	# draw box notces - TRUE: notches on, FALSE: notches off
      boxwex=#<box_boxwex>#,	# scale factor to apply to all box widths
      col=strColor,			# box color(s)
			outline=box_outline,# draw outliers - TRUE: draw, FALSE: no draw
      xaxt="n",				# x-axis type - n: no axis, s: compatibility with l and t
      yaxt="n",				# y-axis type - n: no axis, s: compatibility with l and t
      ylim=listY1lim,			# y1-axis limits
      log=strLogParm1,			# character indicating coordinate log scale - x: x-axis, y: y-axis, b: both
      add=boolAdd,			# add boxes to current plot - TRUE: add, FALSE: new plot
      tck=.01, 				# length of tick marks as a fraction of plot window
      alpha=#<ci_alpha>#  # alpha value to use when calculating confidence intervals
    );
    if( TRUE == boolDumpPoints1 ){
      strPointsFile = sub("\\.data$", ".points1", strDataFile, perl=TRUE);
      write('\nbox stats',file=strPointsFile,append=TRUE)
      write.table(boxes1$stats[nrow(boxes1$stats):1,] , file = strPointsFile, sep = " ", row.names = FALSE, col.names = FALSE, append=TRUE)
      write('\noutliers',file=strPointsFile,append=TRUE)
      write.table(boxes1$out, file = strPointsFile, sep = " ", row.names = FALSE, col.names = FALSE, append=TRUE)
    }
  }
  
  # add the average starts to the plot, if requested
  if( boolBoxAvg ){
    points(listAt, listMeans1[[intPermIndex]], type="p", pch=8);
  }
  boolAdd = TRUE;
}

# specify the y1-axis
axis(
  2,      			# axis of interest, 1: below, 2: left, 3: above and 4: right
  labels=TRUE,			# tick labels on/off
  tick=TRUE,				# tick marks on/off
  tck=.01, 				# length of tick marks as a fraction of plot window
  las=#<ytlab_orient>#,	# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  padj=#<ytlab_perp>#,	# axis label perpendicular location adjustment
  hadj=#<ytlab_horiz>#,	# axis label parallel location adjustment
  cex.axis=#<ytlab_size>#,# relative axis label magnification
  col="gray"				# axis color
);

# y1-axis label
mtext(
  "#<y1_label>#",  		# label
  font=#<ylab_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
  las=0, 					# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  side=2,					# axis of interest, 1: below, 2: left, 3: above and 4: right
  cex=#<ylab_size>#,		# relative axis label magnification
  padj=#<ylab_offset>#,	# axis label perpendicular location adjustment
  adj=#<ylab_align>#,		# axis label parallel location adjustment
  line=1					# margin line, starting at 0 counting outwards
);



# plot the series2 data
if( 0 < length(listDep2Plot) ){
  #restore the plot window limits for y2  

  	par( new=TRUE);
	if( boolBoxPts ==TRUE){   
    # determine the min and max data values
    if( 2 != length(listY2limUsr) ){
      listY2lim = c(min(dfPlot2$stat_value), max(dfPlot2$stat_value));
    } else {
      list21lim = listY2limUsr;
    }
    
    # create the plot window
    plot(
      listX,  				# series x data
      rep(0, length(listX)),	# series y1 data
      type="n",				# series line type - p: points, l: lines, o: overplotted points and lines,  
      #   b or c: points joined by lines, s or S: stair steps, h: histogram, n: nothing 
      xaxt="n",				# x-axis type - n: no axis, s: compatibility with l and t
      xaxs="r",				# x-axis style - r: regular, i: internal
      yaxt="n",				# y1-axis type - n: no axis, s: compatibility with l and t
      yaxs="r",				# x-axis style - r: regular, i: internal
      ylim=listY2lim,			# y2-axis limits
      xlab="",				# x-axis label
      ylab="",				# y2-axis label
      lwd=1,					# line width
      cex.lab=1,				# relative axis label magnification
      cex.main=1,				# relative title magnification
      cex.sub=1,				# relative subtitle magnification
      fg="gray"
    );
    # if y-axis log scale is enabled, set up the axis formatting
    if( boolLogY2 == TRUE ){
      listY2lim = c( 10^floor(log10(listY2lim[1])), 10^ceiling(log10(listY2lim[2])) );
      par( ylog=TRUE, usr=c(par()$usr[1:2], log10(listY2lim[1]), log10(listY2lim[2])), 
           yaxp=c(listY2lim[1:2], 2) );      
    }    
  }
  
  if(boolLogY2==TRUE){      
     if(boolLogY1 == FALSE){
      listY2lim = c( 10^floor(log10(listY2lim[1])), 10^ceiling(log10(listY2lim[2])) );
      par( ylog=TRUE, usr=c(par()$usr[1:2], log10(listY2lim[1]), log10(listY2lim[2])), yaxp=c(listY2lim[1:2], 1) );
    } else{
      par( ylog=TRUE ); 
    }
  }else{
    buffer = (listY2lim[2] - listY2lim[1]) /100 *4;
	par( ylog=FALSE,usr=c(par()$usr[1:2], listY2lim[1]-buffer , listY2lim[2] +buffer) , yaxs="r" );  
  }

  for(intPermIndex in 1:length(listBoxes2)){    
    intPermIndexReal = listPlotOrderSeries2Orig[intPermIndex];
    
    # skip the current box, if requested
    if( FALSE == listPlotDispSeries2[intPermIndex] ){
      next;
    }
  
    # gather the information for the current box
    listAt = listX - (dblIndySpan/2) + (intPermIndexReal  - 1) * dblInc;
    strColor = listColorsSeries2[intPermIndex];
    listBox = listBoxes2[[intPermIndex]];
  
    # if only points are displayed, call the points() function
    if( boolBoxPts == TRUE ){
      intPch = listPchSeries2[intPermIndex];
      intIndy = 1;
      for(strIndy in names(listBox)){
        listPts = listBox[[strIndy]];
        listPtsAt = rep(listAt[intIndy], length(listPts));
        points(
          listPtsAt,   		# x coordinate vector
          listPts,			# y coordinate vector
          type="p",			# type of plot - p: points
          pch=intPch,			# point symbol - see example(points)
          col=strColor		# point color
        );
      intIndy = intIndy + 1;
    }
  }
  
  # otherwise, call the boxplot_ci() function to build the series of boxes
  else {
   if (boolAdd != TRUE){strYaxt="s";}
      else{strYaxt="n";} 
    boxes2 = boxplot_ci(
      listBox,				# box data as a list of vectors
      at=listAt,				# vector of box positions
      notch=#<box_notch>#,	# draw box notces - TRUE: notches on, FALSE: notches off
      boxwex=#<box_boxwex>#,	# scale factor to apply to all box widths
      col=strColor,			# box color(s)
      outline=#<box_outline>#,# draw outliers - TRUE: draw, FALSE: no draw
      xaxt="n",				# x-axis type - n: no axis, s: compatibility with l and t
      yaxt="n",				# y-axis type - n: no axis, s: compatibility with l and t
      ylim=listY2lim,			# y2-axis limits
      log=strLogParm2,			# character indicating coordinate log scale - x: x-axis, y: y-axis, b: both
      add=TRUE,			# add boxes to current plot - TRUE: add, FALSE: new plot
      tck=.01, 				# length of tick marks as a fraction of plot window
      alpha=#<ci_alpha>#  # alpha value to use when calculating confidence intervals
    );
    if( TRUE == boolDumpPoints2 ){
          strPointsFile = sub("\\.data$", ".points2", strDataFile, perl=TRUE);
          write('\nbox stats',file=strPointsFile,append=TRUE)
          write.table(boxes2$stats[nrow(boxes2$stats):1,] , file = strPointsFile, sep = " ", row.names = FALSE, col.names = FALSE, append=TRUE)
          write('\noutliers',file=strPointsFile,append=TRUE)
          write.table(boxes2$out, file = strPointsFile, sep = " ", row.names = FALSE, col.names = FALSE, append=TRUE)
        }
  }
  
  # add the average starts to the plot, if requested
  if( boolBoxAvg ){
    points(listAt, listMeans2[[intPermIndex]], type="p", pch=8);
  }
  boolAdd = TRUE;
}
  # specify the y2-axis
  axis(
    4,      			# axis of interest, 1: below, 2: left, 3: above and 4: right
    labels=TRUE,			# tick labels on/off
    tick=TRUE,				# tick marks on/off
    tck=.01, 				# length of tick marks as a fraction of plot window
    las=#<ytlab_orient>#,	# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    padj=#<ytlab_perp>#,	# axis label perpendicular location adjustment
    hadj=#<ytlab_horiz>#,	# axis label parallel location adjustment
    cex.axis=#<ytlab_size>#,# relative axis label magnification
    col="gray"				# axis color
  );
  # y2-axis label
  mtext(
    "#<y2_label>#",  		# label
    font=#<ylab_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
    las=0, 					# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    side=4,					# axis of interest, 1: below, 2: left, 3: above and 4: right
    cex=#<ylab_size>#,		# relative axis label magnification
    padj=#<ylab_offset>#,	# axis label perpendicular location adjustment
    adj=#<ylab_align>#,		# axis label parallel location adjustment
    line=1					# margin line, starting at 0 counting outwards
  );
  
  
}

# add grid lines to the plot, if requested
if( TRUE == boolGridOn ){
  grid(
		lty=#<grid_lty>#,		# line type - 0: blank, 1: solid, 2: dashed, 3: dotted, 4: dotdash, 5: longdash, 6: twodash
		col="#<grid_col>#",		# line color
		lwd=#<grid_lwd>#,		# line width
    nx=0,					# number of cells in x direction, NULL for default
    ny=NULL					# number of cells in y direction, NULL for default
  );
}

# plot title
mtext(
	"#<plot_title>#",		# label
	font=#<title_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
  las=0, 					# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  side=3,					# axis of interest, 1: below, 2: left, 3: above and 4: right
	cex=#<title_size>#,		# relative magnification
	padj=#<title_offset>#,	# axis label perpendicular location adjustment
	adj=#<title_align>#,	# axis label parallel location adjustment
  line=1					# margin line, starting at 0 counting outwards
);


# specify the x-axis
axis(
  1,    				# axis of interest, 1: below, 2: left, 3: above and 4: right
  at=listX,				# locations of tick marks
	labels=#<indy_label>#,	# axis labels
  tick=TRUE,				# tick marks on/off
  tck=.01, 				# length of tick marks as a fraction of plot window
	las=#<xtlab_orient>#,	# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
	padj=#<xtlab_perp>#,	# axis label perpendicular location adjustment
	hadj=#<xtlab_horiz>#,	# axis label parallel location adjustment
	cex.axis=#<xtlab_size>#,# relative axis label magnification
  col="gray"				# axis color
);


# x-axis label
mtext(
	"#<x_label>#",			# label
	font=#<xlab_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
  las=0, 					# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  side=1,					# axis of interest, 1: below, 2: left, 3: above and 4: right
	cex=#<xlab_size>#,		# relative axis label magnification
	padj=#<xlab_offset>#,	# axis label perpendicular location adjustment
	adj=#<xlab_align>#,		# axis label parallel location adjustment
  line=1					# margin line, starting at 0 counting outwards
);





intX2Axis = 3;
# add the number of stats at each independent axis tick, if requested
if( TRUE == boolShowNStats ){
  axis(
    intX2Axis,				# axis of interest, 1: below, 2: left, 3: above and 4: right
    at=listX,				# locations of tick marks
    labels=listNStats,		# axis labels
    tick=TRUE,				# tick marks on/off
    tck=.01, 				# length of tick marks as a fraction of plot window
    las=1,	# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    padj=1,	# axis label perpendicular location adjustment
    hadj=.5,	# axis label parallel location adjustment
    cex.axis=.8,# relative axis label magnification
    col="gray"				# axis color
  );
  
  mtext(
    "NStats",				# label
    las=0, 					# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    side=intX2Axis,			# axis of interest, 1: below, 2: left, 3: above and 4: right
    font=1,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
    cex=.8,		# relative axis label magnification
    padj=-.5,	# axis label perpendicular location adjustment
    adj=.5,	# axis label parallel location adjustment
    line=1					# margin line, starting at 0 counting outwards
  );
}

# add the number of stats at each independent axis tick, if requested
if( 0 < length(listSeriesNobs) ){
  
  # build a data frame of nobs series data
  dfNobs = dfPlot;
  for(strSeriesNobsVar in names(listSeriesNobs)){
    strSeriesNobsVal = listSeriesNobs[[strSeriesNobsVar]];
    dfNobs = dfNobs[dfNobs[[strSeriesNobsVar]] == strSeriesNobsVal,];
  }
  
  # build the list of nobs, one for each independent variable value
  listNobs = c();
  listObsRate = c();
  for(strIndyVal in listIndy){
    dblTotalSum = sum(dfNobs[dfNobs[[strIndyVar]] == strIndyVal,]$total);
    dblNobsSum = sum(dfNobs[dfNobs[[strIndyVar]] == strIndyVal,]$nobs);
    listNobs = append(listNobs, dblNobsSum);
    listObsRate = append(listObsRate, dblNobsSum / dblTotalSum);
  }
  listNobsLabels = gsub(" ", "", formatC(round(listNobs), format="G", digits=6));
  listObsRateLabels = formatC(listObsRate, format="f", digits=4);
  listX2Labels = paste(listObsRateLabels, paste("(", listNobsLabels, ")", sep=""));
  
  axis(
    3,						# axis of interest, 1: below, 2: left, 3: above and 4: right
    at=listX,				# locations of tick marks
    labels=listX2Labels,	# axis labels
    tick=TRUE,				# tick marks on/off
    tck=.01, 				# length of tick marks as a fraction of plot window
		las=#<x2tlab_orient>#,	# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
		padj=#<x2tlab_perp>#,	# axis label perpendicular location adjustment
		hadj=#<x2tlab_horiz>#,	# axis label parallel location adjustment
		cex.axis=#<x2tlab_size>#,# relative axis label magnification
    col="black"				# axis color
  );
  
  mtext(
    "Observation Rate",		# label
    las=0, 					# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    side=3,					# axis of interest, 1: below, 2: left, 3: above and 4: right
		font=#<x2lab_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
		cex=#<x2lab_size>#,		# relative axis label magnification
		padj=#<x2lab_offset>#,	# axis label perpendicular location adjustment
		adj=#<x2lab_align>#,	# axis label parallel location adjustment
    line=1					# margin line, starting at 0 counting outwards
  );
}

# build the legend, if it is not supplied by the user
listLegend1NotOrdered=c();
listLegend=c();
for(strLegendInd in 1:length(listAllStats1)){
  strLegend = names(listAllStats1)[strLegendInd]
  listLegend1NotOrdered[strLegendInd] = strLegend;
  listLegend[listPlotOrderSeries1Orig[strLegendInd]] = strLegend;
}
if(length(listAllStats2) > 0){
  listLegend2NotOrdered=c();
  for(strLegendInd in 1:length(listAllStats2)){
    strLegend = names(listAllStats2)[strLegendInd]
    listLegend2NotOrdered[strLegendInd] = strLegend;
    listLegend[listPlotOrderSeries2Orig[strLegendInd]] = strLegend;
  }
}
#replace with user's legends
for(index in 1:length(listLegendUsr)){
    if(nchar(listLegendUsr[index]) > 0){
      listLegend[index]=listLegendUsr[index];
      #add revision if needed
      if( index <= length(revision_stats)){
        ww_run_title = paste("WW Runs Test:", revision_stats[[index]]$ww_run, sep = " ");
        ac_test_title = paste("Auto-Corr Test: p=", revision_stats[[index]]$auto_cor_p, ",r=", revision_stats[[index]]$auto_cor_r, sep = " ");
        listLegend[index] = paste(listLegend[index],  " (");
        listLegend[index] = paste(listLegend[index], ww_run_title, " ");
        listLegend[index] = paste(listLegend[index], ac_test_title, " ");
        listLegend[index] = paste(listLegend[index],  ")");
      }
    }
}



# display on the labels and colors for visible series
listLegendDisp = listLegend[listPlotDispOrdered];
listColorsDisp = listColorsOrdered[listPlotDispOrdered];

legend(
  x="bottom",				# x coordinate of legend
  listLegendDisp,			# vector of legend labels
  col=listColorsDisp,		# vector of point and line colors
  lty=1,					# vector of line types
  lwd=5,					# line width
	cex=#<legend_size>#,	# relative magnification
	bty="#<legend_box>#",	# legend box type - o: box, n: none
  #bg="#EEEEEEFF",		# background color
  #box.lty=,				# legend box line type
  #box.lwd=,				# legend box line width
  #horiz=FALSE,			# horizontal configuration
  #adj=.05,				# string adjustment for text
  xpd=TRUE,				# clipping - FALSE: plot region, TRUE: figure region, NA: device region
	ncol=#<legend_ncol>#,	# number of columns in legend
  #agginset=c(0, -.25),	# inset distance from margin
	inset=#<legend_inset>#,	# inset distance from margin
  x.intersp=1,			# horizontal character spacing factor
  y.intersp=.8			# vertical character spacing factor
);

# plot caption
mtext(
	"#<plot_caption>#",		# caption
	font=#<caption_weight>#,# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
	col="#<caption_col>#",	# font color
  las=0, 					# axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  side=1,					# axis of interest, 1: below, 2: left, 3: above and 4: right
	cex=#<caption_size>#,	# relative magnification
	padj=#<caption_offset>#,# axis label perpendicular location adjustment
	adj=#<caption_align>#,	# axis label parallel location adjustment
  line=1					# margin line, starting at 0 counting outwards
);

#<plot_cmd>#

invisible(dev.off());