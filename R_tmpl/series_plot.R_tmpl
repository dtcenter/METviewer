setwd("#<r_work>#");

source("include/Compute_STDerr.R");
source("include/util_plot.R");



strDataFile = "#<data_file>#";
strPlotFile = "#<plot_file>#";

#
#  Plot Control Variables
#
boolEqualizeByIndep = #<equalize_by_indep>#;
boolEventEqual  = #<event_equal>#;
boolVertPlot  = #<vert_plot>#;
boolXReverse  = #<x_reverse>#;
boolShowNStats  = #<show_nstats>#;
boolIndy1Stagger= #<indy1_stagger>#;
boolIndy2Stagger= #<indy2_stagger>#;
boolGridOn    = #<grid_on>#;
boolSyncAxes  = #<sync_axes>#;
boolDumpPoints1  = #<dump_points1>#;
boolDumpPoints2  = #<dump_points2>#;
boolLogY1    = #<log_y1>#;
boolLogY2    = #<log_y2>#;
boolVarianceInflationFactor = #<variance_inflation_factor>#;

listY1limUsr  = #<y1_lim>#;

listX1limUsr  = #<x1_lim>#;

listY2limUsr  = #<y2_lim>#;

listPlotCI    = #<plot_ci>#;

listPlotDisp  = #<plot_disp>#;

listShowSignif  = #<show_signif>#;

listPlotOrderSeries  = #<order_series>#;

dblAlpha    = #<ci_alpha>#;

strIndyVar    = "#<indy_var>#";

listIndy = #<indy_list>#;

listIndyPlotVal = #<indy_plot_val>#;

listDep1Plot = #<dep1_plot>#;

listDep2Plot = #<dep2_plot>#;	

listAggVal = #<agg_list>#;

listSeries1Val = #<series1_list>#;

listSeries2Val = #<series2_list>#;

listFixedValEx = #<fix_val_list_eq>#;

listDep1Scale = #<dep1_scale>#;

listDep2Scale = #<dep2_scale>#;

listLegendUsr = #<legend>#;

strPlotStat = "#<plot_stat>#";

listDiffSeries1=#<series1_diff_list>#;

listDiffSeries2=#<series2_diff_list>#;

listColors = #<colors>#;
listPch = #<pch>#;
listType = #<type>#;
listLty = #<lty>#;
listLwd = #<lwd>#;
listConSeries = #<con_series>#;


#
#  Build the series data for the plot 
#

#if fcst_var is a special char - read it as-is and do not convert
sampleData = read.delim(strDataFile,nrows=5);
classes <- sapply(sampleData, class);
numeric_columns <- c('stat_value', 'stat_bcl', 'stat_bcu', 'stat_ncu', 'stat_ncl','fbs', 'fss');
integer_columns <- c('fcst_lead','nstats');
character_columns <- c('fcst_var', 'model', 'stat_name', 'object_id', 'cluster_id', 'object_cat');
for(col in 1:ncol(sampleData)){
  if ( is.element( names(classes)[col] , numeric_columns) ){
    classes[col]='numeric';
  } else if ( is.element( names(classes)[col] , integer_columns) ){
    classes[col]='integer';
  } else if ( is.element( names(classes)[col] , character_columns) ){
    classes[col]='character';
  }
}

dfPlot = read.delim(strDataFile,colClasses = classes);


# build the list of independent values
listX = 1:length(listIndy);
if( length(listIndyPlotVal) == length(listIndy) ){
  listXForAxis = listIndyPlotVal;
}else{
  listXForAxis = listX;
}
if( length(listX1limUsr) > 0 ) {
  listXlim = listX1limUsr
}else{
  listXlim = c(min(listX), max(listX))
}

if( TRUE == boolXReverse ){
  listXlim = rev(listXlim)
}

# run event equalizer, if requested
if( FALSE != boolEventEqual  ){


  dfPlot1 = data.frame();
  #list all fixed variables
  listFixVars=c();
  listFixVarVals = c();
  if(length(listFixedValEx) > 0){
    for(index in 1:length(listFixedValEx)){
      if(is.null(listFixVars)){
        listFixVars = names(listFixedValEx[index]);
        listFixVarVals = permute(listFixedValEx[index]);
      }else{
        listFixVars =  append(listFixVars, names(listFixedValEx[index]));
        listFixVarVals = append(listFixVarVals, permute(listFixedValEx[index]));
      }
    }
  }

  for( strDep1Name in names(listDep1Plot) ){
    for( strDep1Stat in listDep1Plot[[strDep1Name]] ){
      fPlot = dfPlot;
      for(strSeriesVal in names(listSeries1Val)){
        vectValPerms = c();
        for(index in 1:length(listSeries1Val[[strSeriesVal]])){
          vectValPerms= append(vectValPerms, strsplit(listSeries1Val[[strSeriesVal]][index], ":")[[1]]);
        }
        fPlot = fPlot[fPlot$fcst_var == strDep1Name & fPlot[[strSeriesVal]] %in% vectValPerms & fPlot$stat_name %in% strDep1Stat,  ];
      }
      fPlot = eventEqualize(fPlot, strIndyVar, listIndy, listSeries1Val, listFixVars,listFixVarVals, boolEqualizeByIndep, FALSE);
      dfPlot1 = rbind(dfPlot1, fPlot);
    }

  }

  #if the second Y axis is present - run event equalizer on Y1
  # and then run event equalizer on Y1 and Y2 equalized data
  if(length(listSeries2Val) > 0){
    dfPlot2 = data.frame();
    for( strDep2Name in names(listDep2Plot) ){
      for( strDep2Stat in listDep2Plot[[strDep2Name]] ){
        fPlot = dfPlot;
        for(strSeriesVal in names(listSeries2Val)){
          vectValPerms = c();
          for(index in 1:length(listSeries2Val[[strSeriesVal]])){
            vectValPerms= append(vectValPerms, strsplit(listSeries2Val[[strSeriesVal]][index], ":")[[1]]);
          }
          fPlot = fPlot[fPlot$fcst_var == strDep1Name & fPlot[[strSeriesVal]] %in% vectValPerms & fPlot$stat_name %in% strDep2Stat,  ];
        }
        fPlot = eventEqualize(fPlot, strIndyVar, listIndy, listSeries2Val, listFixVars,listFixVarVals, boolEqualizeByIndep, FALSE);
        dfPlot2 = rbind(dfPlot2, fPlot);
      }
    }

    dfPlot = rbind(dfPlot1, dfPlot2);
    listSeriesVal=list();
    for( seriesVal in names(listSeries1Val) ){
      listSeriesVal[[seriesVal]] = append(listSeries1Val[[seriesVal]], listSeries2Val[[seriesVal]]);
    }
    listSeriesVal$model = append(listSeries1Val$model,listSeries2Val$model)
    dfPlot = eventEqualize(dfPlot, strIndyVar, listIndy, listSeriesVal, listFixVars,listFixVarVals,boolEqualizeByIndep, TRUE);
  }else{
    dfPlot = dfPlot1;
  }
  strAfrerEqualizeFile = sub("\\.data$", ".dataAfterEq", strDataFile, perl=TRUE);
  write.table(dfPlot, file=strAfrerEqualizeFile, quote=FALSE, row.names=FALSE, col.names=TRUE, sep = "\t");

}



# order the series formatting

listColorsOrdered=c();
listLtyOrdered=c();
listLwdOrdered=c();
listPchOrdered=c();
listPlotDispOrdered=c();
listShowSignifOrdered=c();
listTypeOrdered=c();
for(index in 1:length(listPlotOrderSeries)){
  listLwdOrdered[ listPlotOrderSeries[index] ] = listLwd[index];
  listColorsOrdered[ listPlotOrderSeries[index] ]=listColors[index];
  listLtyOrdered[ listPlotOrderSeries[index] ]=listLty[index];
  listPchOrdered[ listPlotOrderSeries[index] ]=listPch[index];
  listPlotDispOrdered[ listPlotOrderSeries[index] ]=listPlotDisp[index];
  listShowSignifOrdered[ listPlotOrderSeries[index] ]=listShowSignif[index];
  listTypeOrdered[ listPlotOrderSeries[index] ]=listType[index];
}

# calculate the number of Y1 series per dep stat
intNumSeries1 = numSeries(listSeries1Val, listDep1Plot);
intNumSeries1Diff = length(listDiffSeries1);
intNumSeries1Dep = nrow( permute(listSeries1Val) );


# calculate the number of Y2 series per dep stat
intNumSeries2=0;
intNumSeries2Dep=0;
intNumSeries2Diff=0;
if( 0 < length(listDep2Plot) ){
  intNumSeries2 = numSeries(listSeries2Val, listDep2Plot);
  intNumSeries2Diff = length(listDiffSeries2);
  intNumSeries2Dep = nrow( permute(listSeries2Val) );
}


# separate formatting for Y1
indexesNumSeries1 = 1:intNumSeries1;
listPlotDispSeries1 = listPlotDisp[indexesNumSeries1];
listShowSignifSeries1 = listShowSignif[indexesNumSeries1];
listPchSeries1 = listPch[indexesNumSeries1];
listTypeSeries1 = listType[indexesNumSeries1];
listLtySeries1 = listLty[indexesNumSeries1];
listLwdSeries1 = listLwd[indexesNumSeries1];
listPlotCISeries1 = listPlotCI[indexesNumSeries1];
listColorsSeries1 = listColors[indexesNumSeries1];
listConSeries1 = listConSeries[indexesNumSeries1];
listPlotOrderSeries1Orig = listPlotOrderSeries[indexesNumSeries1];

# add formatting for DIFF Y1 if exists
if(intNumSeries1Diff > 0){
  indexesNumSeries1Diff = (intNumSeries1+intNumSeries2 +1):(intNumSeries1+intNumSeries2 + intNumSeries1Diff);
  listPlotOrderSeries1Orig = append(listPlotOrderSeries1Orig,listPlotOrderSeries[indexesNumSeries1Diff]);
  listPlotDispSeries1 = append(listPlotDispSeries1,listPlotDisp[indexesNumSeries1Diff]);
  listShowSignifSeries1 = append(listShowSignifSeries1,listShowSignif[indexesNumSeries1Diff]);
  listColorsSeries1 = append (listColorsSeries1,  listColors[indexesNumSeries1Diff]);
  listPchSeries1 = append (listPchSeries1,  listPch[indexesNumSeries1Diff]);
  listTypeSeries1 = append (listTypeSeries1,  listType[indexesNumSeries1Diff]);
  listLtySeries1 = append (listLtySeries1,  listLty[indexesNumSeries1Diff]);
  listLwdSeries1 = append (listLwdSeries1,  listLwd[indexesNumSeries1Diff]);
  listPlotCISeries1 = append (listPlotCISeries1,  listPlotCI[indexesNumSeries1Diff]);
  listConSeries1 = append (listConSeries1,  listConSeries[indexesNumSeries1Diff]);
}

listPlotOrderSeries1Part=c();
maxx = max(listPlotOrderSeries1Orig)+1;
for(index in 1:length(listPlotOrderSeries1Orig)){
  indOfMin=which.min(listPlotOrderSeries1Orig);
  listPlotOrderSeries1Part[[indOfMin]] = index;
  listPlotOrderSeries1Orig[[indOfMin]] = maxx;
}

# separate formatting for Y2 if exists
if(intNumSeries2 > 0){
  indexesNumSeries2 = (intNumSeries1+1):(intNumSeries1+intNumSeries2);
  listPlotDispSeries2 = listPlotDisp[indexesNumSeries2];
  listShowSignifSeries2 = listShowSignif[indexesNumSeries2];
  listPlotOrderSeries2Orig = listPlotOrderSeries[indexesNumSeries2];
  listColorsSeries2 = listColors[indexesNumSeries2];
  listPchSeries2 = listPch[indexesNumSeries2];
  listTypeSeries2 = listType[indexesNumSeries2];
  listLtySeries2 = listLty[indexesNumSeries2];
  listLwdSeries2 = listLwd[indexesNumSeries2];
  listPlotCISeries2 = listPlotCI[indexesNumSeries2];
  listConSeries2 = listConSeries[indexesNumSeries2];

  # add formatting for DIFF Y2 if exists
  if(intNumSeries2Diff > 0 ){
    indexesNumSeries2Diff = (intNumSeries1+intNumSeries2 + intNumSeries1Diff +1):length(listPlotDisp);
    listPlotOrderSeries2Orig = append(listPlotOrderSeries2Orig,listPlotOrderSeries[indexesNumSeries2Diff]);
    listPlotDispSeries2 = append(listPlotDispSeries2,listPlotDisp[indexesNumSeries2Diff]);
    listShowSignifSeries2 = append(listShowSignifSeries2,listShowSignif[indexesNumSeries2Diff]);
    listColorsSeries2 = append (listColorsSeries2,  listColors[indexesNumSeries2Diff]);
    listPchSeries2 = append (listPchSeries2,  listPch[indexesNumSeries2Diff]);
    listTypeSeries2 = append (listTypeSeries2,  listType[indexesNumSeries2Diff]);
    listLtySeries2 = append (listLtySeries2,  listLty[indexesNumSeries2Diff]);
    listLwdSeries2 = append (listLwdSeries2,  listLwd[indexesNumSeries2Diff]);
    listPlotCISeries2 = append (listPlotCISeries2,  listPlotCI[indexesNumSeries2Diff]);
    listConSeries2 = append (listConSeries2,  listConSeries[indexesNumSeries2Diff]);
  }
  listPlotOrderSeries2Part=c();
  maxx = max(listPlotOrderSeries2Orig)+1;
  for(index in 1:length(listPlotOrderSeries2Orig)){
    indOfMin=which.min(listPlotOrderSeries2Orig);
    listPlotOrderSeries2Part[[indOfMin]] = index;
    listPlotOrderSeries2Orig[[indOfMin]] = maxx;
  }
}



# build the y1 plot series using information in the plot dataframe
listSeries1 = list();
listLegend = c();
listLegendNotOrdered = c();
listAllStats=list();
intLegendIndex=1;
for( strDep1Name in names(listDep1Plot) ){
  for( strDep1Stat in listDep1Plot[[strDep1Name]] ){

    # gather the stats that pertain to the current fcst_var and stat
    dfPlotStat = dfPlot[dfPlot$fcst_var == strDep1Name & dfPlot$stat_name == strDep1Stat,];
    dfPlotStat = scaleStats(dfPlotStat, listDep1Scale, paste(strDep1Name, "_", strDep1Stat, sep=""));

    # determine the visibility of the series for the current stat

    # build the y1 plot series using information in the plot dataframe
    listAllStats1 = buildAllStats(dfPlotStat, listSeries1Val,strDep1Stat,strDep1Name);
    listAllStats = append(listAllStats, listAllStats1);
  }
}

revision_stats = c();
for( ind in 1: length(listAllStats) ){
  listAllStatsName = names(listAllStats)[ind];
  allStatsArr = strsplit(listAllStatsName, " ")[[1]]
  fcst_var = allStatsArr[length(allStatsArr)-1]

  #always use "sum" for "CNTSUM" stat
  stat =strPlotStat;
  if(substring(strDep1Stat, 1, nchar("CNTSUM")) == "CNTSUM"){
    stat = "sum";
  }

  listPlotData1 = buildSeriesData(listAllStats[[listAllStatsName]], strIndyVar, listIndy, strDep1Stat, listSeries1Val, listPlotDisp[indexesNumSeries1[ind]],
  listPlotCI[indexesNumSeries1[ind]], dblAlpha, boolVarianceInflationFactor, stat);
  listSeries1 = append(listSeries1, listPlotData1$series);
  if( TRUE == exists("listNStats") ){
    if("nstats" %in% names(listAllStats[[listAllStatsName]])){
      listNStats = listNStats + listAllStats[[listAllStatsName]]$nstats;
    }else{
      listNStats = listNStats + listPlotData1$nstats;
    }
  }else {
    if("nstats" %in% names(listAllStats[[listAllStatsName]])){
      listNStats = listAllStats[[listAllStatsName]]$nstats;
    }else{
      listNStats = listPlotData1$nstats;
    }
  }
  if (grepl("^REV_", fcst_var)){
      used_names <- names(listAllStats[[listAllStatsName]]) %in% c("stat_value", "revision_id")
      stats = calculateMtdRevisionStats(listAllStats[[listAllStatsName]][used_names]);
      ww_run_title = paste("WW Runs Test:", stats$ww_run, sep = " ");
      ac_test_title = paste("Auto-Corr Test: p=", stats$auto_cor_p, ",r=", stats$auto_cor_r, sep = " ");
      listAllStatsName = paste(listAllStatsName,  " (");
      listAllStatsName = paste(listAllStatsName, ww_run_title, " ");
      listAllStatsName = paste(listAllStatsName, ac_test_title, " ");
      listAllStatsName = paste(listAllStatsName,  ")");
      cat('\n', listAllStatsName, '\n');
      revision_stats[[length(revision_stats)+1]] <- stats;
  }
  if ( strDep1Stat == 'DMAP_GBETA'){
      unique_beta_value = unique(listAllStats[[listAllStatsName]][c('beta_value')])
      if (nrow(unique_beta_value) > 1){
        cat("\n  WARNING: note that beta_value differs for one or more GBETA values for ",listAllStatsName ,", so that comparisons across cases may not be comparable.\n");
      }
   }
  listLegendNotOrdered[intLegendIndex] = listAllStatsName;
  intLegendIndex = intLegendIndex + 1;
}


# build the y2 plot series using information in the plot dataframe, if available
if( 0 < length(listDep2Plot) ){
  listAllStatsY2=list();
  listSeries2 = list();
  for( strDep2Name in names(listDep2Plot) ){
    for( strDep2Stat in listDep2Plot[[strDep2Name]] ){

      # gather the stats that pertain to the current fcst_var and stat
      dfPlotStat = dfPlot[dfPlot$fcst_var == strDep2Name & dfPlot$stat_name == strDep2Stat,];
      dfPlotStat = scaleStats(dfPlotStat, listDep2Scale, paste(strDep2Name, "_", strDep2Stat, sep=""));

      # build the y2 plot series using information in the plot dataframe
      listAllStats2 = buildAllStats(dfPlotStat, listSeries2Val,strDep2Stat,strDep2Name);
      listAllStatsY2 = append(listAllStatsY2, listAllStats2);
    }
  }


  for( ind in 1: length(listAllStatsY2) ){
    listAllStatsName = names(listAllStatsY2)[ind];
    allStatsArr = strsplit(listAllStatsName, " ")[[1]]
    fcst_var = allStatsArr[length(allStatsArr)-1]

    #alvays use "sum" for "CNTSUM" stat
    stat =strPlotStat;
    if( substring(strDep1Stat, 1, nchar("CNTSUM")) == "CNTSUM" ){
      stat = "sum";
    }
    listPlotData2 = buildSeriesData(listAllStatsY2[[listAllStatsName]], strIndyVar, listIndy, strDep2Stat, listSeries2Val, listPlotDisp[indexesNumSeries2[ind]],
    listPlotCI[indexesNumSeries2[ind]], dblAlpha, boolVarianceInflationFactor, stat);
    listSeries2 = append(listSeries2, listPlotData2$series);
    if( TRUE == exists("listNStats") ){
      if("nstats" %in% names(listAllStatsY2[[listAllStatsName]])){
        listNStats = listNStats + listAllStatsY2[[listAllStatsName]]$nstats;
      }else{
        listNStats = listNStats + listPlotData2$nstats;
      }
    } else  {
      if("nstats" %in% names(listAllStatsY2[[listAllStatsName]])){
        listNStats = listAllStatsY2[[listAllStatsName]]$nstats;
      }else{
        listNStats = listPlotData2$nstats;
      }
    }
      if (grepl("^REV_", fcst_var)){
          used_names <- names(listAllStatsY2[[listAllStatsName]]) %in% c("stat_value", "revision_id")
          stats = calculateMtdRevisionStats(listAllStatsY2[[listAllStatsName]][used_names]);
          ww_run_title = paste("WW Runs Test:", stats$ww_run, sep = " ");
          ac_test_title = paste("Auto-Corr Test: p=", stats$auto_cor_p, ",r=", stats$auto_cor_r, sep = " ");
          listAllStatsName = paste(listAllStatsName,  " (");
          listAllStatsName = paste(listAllStatsName, ww_run_title, " ");
          listAllStatsName = paste(listAllStatsName, ac_test_title, " ");
          listAllStatsName = paste(listAllStatsName,  ")");
          cat('\n', listAllStatsName, '\n');
          revision_stats[[length(revision_stats)+1]] <- stats;
      }
      if ( strDep2Stat == 'DMAP_GBETA'){
            unique_beta_value = unique(listAllStats[[listAllStatsName]][c('beta_value')])
            if (nrow(unique_beta_value) > 1){
              cat("\n  WARNING: note that beta_value differs for one or more GBETA values for ",listAllStatsName,", so that comparisons across cases may not be comparable.\n");
            }
         }
    listLegendNotOrdered[intLegendIndex] = listAllStatsName;
    intLegendIndex = intLegendIndex + 1;
  }
}

#add Y1 DIFF series - if exist
if(length(listDiffSeries1) > 0){
  for( diffSeries1Name in 1: length(listDiffSeries1) ){ #1,2....

    #get  names of DIFF series
    diffSeriesVec = listDiffSeries1[[diffSeries1Name]];
    derivedCurveName = getDerivedCurveName(diffSeriesVec);
    #check if the input frame already has diff series  ( from calculation agg stats )
    listSeriesVar = names(listSeries1Val);

    for(var in listSeriesVar){
      dfStatsIndy1 = dfPlot[dfPlot[[var]] == derivedCurveName ,];
    }
    if(nrow(dfStatsIndy1) == 0){

      #get plot data to calculate DIFF
      plotData1 = listAllStats[[ diffSeriesVec[1] ]];
      plotData2 = listAllStats[[ diffSeriesVec[2] ]];

      plotDataDiff=list();
      listFields = names(plotData1);
      for(indy in listIndy){
        dfStatsIndy1 = plotData1[plotData1[[strIndyVar]] == indy,];
        dfStatsIndy2 = plotData2[plotData2[[strIndyVar]] == indy,];

        if ("fcst_valid_beg" %in% listFields) {
          uniqueDates = nrow(unique(dfStatsIndy1[c("fcst_valid_beg", "fcst_lead", "stat_name")]))
        } else if ("fcst_valid" %in% listFields) {
          uniqueDates = nrow(unique(dfStatsIndy1[c("fcst_valid", "fcst_lead", "stat_name")]))
        } else if ("fcst_init_beg" %in% listFields) {
          uniqueDates = nrow(unique(dfStatsIndy1[c("fcst_init_beg", "fcst_lead", "stat_name")]))
        } else {
          uniqueDates = nrow(unique(dfStatsIndy1[c("fcst_init", "fcst_lead", "stat_name")]))
        }
        if (nrow(dfStatsIndy1) != uniqueDates) {
          stop("Derived curve can't be calculated. Multiple values for one valid date/fcst_lead")
        }

        #sort data
        if ("fcst_valid_beg" %in% listFields) {
          dfStatsIndy1 = dfStatsIndy1[order(dfStatsIndy1$fcst_valid_beg, dfStatsIndy1$fcst_lead, dfStatsIndy1$stat_name),];
          dfStatsIndy2 = dfStatsIndy2[order(dfStatsIndy2$fcst_valid_beg, dfStatsIndy2$fcst_lead, dfStatsIndy2$stat_name),];
        }
        if ("fcst_valid" %in% listFields) {
          dfStatsIndy1 = dfStatsIndy1[order(dfStatsIndy1$fcst_valid, dfStatsIndy1$fcst_lead, dfStatsIndy1$stat_name),];
          dfStatsIndy2 = dfStatsIndy2[order(dfStatsIndy2$fcst_valid, dfStatsIndy2$fcst_lead, dfStatsIndy2$stat_name),];
        }
        if ("fcst_init_beg" %in% listFields) {
          dfStatsIndy1 = dfStatsIndy1[order(dfStatsIndy1$fcst_init_beg, dfStatsIndy1$fcst_lead, dfStatsIndy1$stat_name),];
          dfStatsIndy2 = dfStatsIndy2[order(dfStatsIndy2$fcst_init_beg, dfStatsIndy2$fcst_lead, dfStatsIndy2$stat_name),];
        }
        if ("fcst_init" %in% listFields) {
          dfStatsIndy1 = dfStatsIndy1[order(dfStatsIndy1$fcst_init, dfStatsIndy1$fcst_lead, dfStatsIndy1$stat_name),];
          dfStatsIndy2 = dfStatsIndy2[order(dfStatsIndy2$fcst_init, dfStatsIndy2$fcst_lead, dfStatsIndy2$stat_name),];
        }

        dfStatsIndy1$stat_value = calcDerivedCurveValue(dfStatsIndy1$stat_value, dfStatsIndy2$stat_value, derivedCurveName);
        if ('stat_bcl' %in% names(dfStatsIndy1)) {
          dfStatsIndy1$stat_bcl = calcDerivedCurveValue(dfStatsIndy1$stat_bcl, dfStatsIndy2$stat_bcl, derivedCurveName);
        }
        if('stat_bcu' %in% names(dfStatsIndy1)){
          dfStatsIndy1$stat_bcu = calcDerivedCurveValue(dfStatsIndy1$stat_bcu, dfStatsIndy2$stat_bcu,derivedCurveName);
        }

        if(length(names(plotDataDiff)) == 0){
          plotDataDiff = dfStatsIndy1;
        }else{
          plotDataDiff = merge(plotDataDiff,dfStatsIndy1,all=TRUE);
        }
      }
    }else{
      plotDataDiff = dfStatsIndy1;
    }

    #build series data using DIFF
    listPlotData1 = buildSeriesData(plotDataDiff, strIndyVar, listIndy, strDep1Stat, listSeries1Val, listPlotDisp[indexesNumSeries1Diff[diffSeries1Name]],
    listPlotCI[indexesNumSeries1Diff[diffSeries1Name]], dblAlpha, boolVarianceInflationFactor, strPlotStat);
    listSeries1 = append(listSeries1, listPlotData1$series);
    if( TRUE == exists("listNStats") ){
      listNStats = listNStats + listPlotData1$nstats;
    } else {
      listNStats = listPlotData1$nstats;
    }

    #create a legend
    listLegendNotOrdered[intLegendIndex] = derivedCurveName;
    intLegendIndex = intLegendIndex + 1;
  }
}



#add Y2 DIFF series - if exist
if(length(listDiffSeries2) > 0){
  for( diffSeries2Name in 1: length(listDiffSeries2) ){ #1,2....

    #get  names of DIFF series
    diffSeriesVec = listDiffSeries2[[diffSeries2Name]];
    derivedCurveName = getDerivedCurveName(diffSeriesVec);

    #check if the input frame already has diff series  ( from calculation agg stats )
    listSeriesVar = names(listSeries2Val);

    for(var in listSeriesVar){
      dfStatsIndy1 = dfPlot[dfPlot[[var]] == derivedCurveName ,];
    }

    if(nrow(dfStatsIndy1) == 0){

      #get plot data to calculate DIFF
      plotData1 = listAllStatsY2[[ diffSeriesVec[1] ]];
      plotData2 = listAllStatsY2[[ diffSeriesVec[2] ]];

      plotDataDiff=list();
      listFields = names(plotData1);
      for(indy in listIndy){
        dfStatsIndy1 = plotData1[plotData1[[strIndyVar]] == indy,];
        dfStatsIndy2 = plotData2[plotData2[[strIndyVar]] == indy,];

        if ("fcst_valid_beg" %in% listFields) {
          uniqueDates = nrow(unique(dfStatsIndy1[c("fcst_valid_beg", "fcst_lead", "stat_name")]))
        } else if ("fcst_valid" %in% listFields) {
          uniqueDates = nrow(unique(dfStatsIndy1[c("fcst_valid", "fcst_lead", "stat_name")]))
        } else if ("fcst_init_beg" %in% listFields) {
          uniqueDates = nrow(unique(dfStatsIndy1[c("fcst_init_beg", "fcst_lead", "stat_name")]))
        } else {
          uniqueDates = nrow(unique(dfStatsIndy1[c("fcst_init", "fcst_lead", "stat_name")]))
        }
        if (nrow(dfStatsIndy1) != uniqueDates) {
          stop("Derived curve can't be calculated. Multiple values for one valid date/fcst_lead")
        }

        #sort data
        if ("fcst_valid_beg" %in% listFields) {
          dfStatsIndy1 = dfStatsIndy1[order(dfStatsIndy1$fcst_valid_beg, dfStatsIndy1$fcst_lead, dfStatsIndy1$stat_name),];
          dfStatsIndy2 = dfStatsIndy2[order(dfStatsIndy2$fcst_valid_beg, dfStatsIndy2$fcst_lead, dfStatsIndy2$stat_name),];
        }
        if ("fcst_valid" %in% listFields) {
          dfStatsIndy1 = dfStatsIndy1[order(dfStatsIndy1$fcst_valid, dfStatsIndy1$fcst_lead, dfStatsIndy1$stat_name),];
          dfStatsIndy2 = dfStatsIndy2[order(dfStatsIndy2$fcst_valid, dfStatsIndy2$fcst_lead, dfStatsIndy2$stat_name),];
        }
        if ("fcst_init_beg" %in% listFields) {
          dfStatsIndy1 = dfStatsIndy1[order(dfStatsIndy1$fcst_init_beg, dfStatsIndy1$fcst_lead, dfStatsIndy1$stat_name),];
          dfStatsIndy2 = dfStatsIndy2[order(dfStatsIndy2$fcst_init_beg, dfStatsIndy2$fcst_lead, dfStatsIndy2$stat_name),];
        }
        if ("fcst_init" %in% listFields) {
          dfStatsIndy1 = dfStatsIndy1[order(dfStatsIndy1$fcst_init, dfStatsIndy1$fcst_lead, dfStatsIndy1$stat_name),];
          dfStatsIndy2 = dfStatsIndy2[order(dfStatsIndy2$fcst_init, dfStatsIndy2$fcst_lead, dfStatsIndy2$stat_name),];
        }

        dfStatsIndy1$stat_value = calcDerivedCurveValue(dfStatsIndy1$stat_value, dfStatsIndy2$stat_value, derivedCurveName);
        if ('stat_bcl' %in% names(dfStatsIndy1)) {
          dfStatsIndy1$stat_bcl = calcDerivedCurveValue(dfStatsIndy1$stat_bcl, dfStatsIndy2$stat_bcl, derivedCurveName);
        }
        if('stat_bcu' %in% names(dfStatsIndy1)){
          dfStatsIndy1$stat_bcu = calcDerivedCurveValue(dfStatsIndy1$stat_bcu, dfStatsIndy2$stat_bcu,derivedCurveName);
        }
        if(length(names(plotDataDiff)) == 0){
          plotDataDiff = dfStatsIndy1;
        }else{
          plotDataDiff = merge(plotDataDiff,dfStatsIndy1,all=TRUE);
        }
      }
    }else{
      plotDataDiff = dfStatsIndy1;
    }

    listPlotData2 = buildSeriesData(plotDataDiff, strIndyVar, listIndy, strDep2Stat, listSeries2Val, listPlotDisp[indexesNumSeries2Diff[diffSeries2Name]],
    listPlotCI[indexesNumSeries2Diff[diffSeries2Name]], dblAlpha, boolVarianceInflationFactor, strPlotStat);
    listSeries2 = append(listSeries2, listPlotData2$series);

    if( TRUE == exists("listNStats") ){
      listNStats = listNStats + listPlotData2$nstats;
    } else {
      listNStats = listPlotData2$nstats;
    }

    listLegendNotOrdered[intLegendIndex] = derivedCurveName;
    intLegendIndex = intLegendIndex + 1;
  }
}


# sort and dump the y1 axis series data points into a file suffixed .points1
if( TRUE == boolDumpPoints1 ){
  listSeriesOrdered=list();
  oldInd=1;
  for(index in 1:length(listPlotOrderSeries1Part)){
    newInd = (3 * listPlotOrderSeries1Part[index]) -2;
    for(i in 0:2){
      listSeriesOrdered[newInd+i]=listSeries1[oldInd+i];
    }
    oldInd = oldInd +3;
  }

  strPointsFile = sub("\\.data$", ".points1", strDataFile, perl=TRUE);
  write.table(listSeriesOrdered, file=strPointsFile, quote=FALSE, row.names=FALSE, col.names=FALSE);
}

# sort and dump the y2 axis series data points into a file suffixed .points2
if( TRUE == boolDumpPoints2 && intNumSeries2){
  listSeriesOrdered=list();
  oldInd=1;
  for(index in 1:length(listPlotOrderSeries2Part)){
    newInd = (3 * listPlotOrderSeries2Part[index]) -2;
    for(i in 0:2){
      listSeriesOrdered[newInd+i]=listSeries2[oldInd+i];
    }
    oldInd = oldInd +3;
  }

  strPointsFile = sub("\\.data$", ".points2", strDataFile, perl=TRUE);
  write.table(listSeriesOrdered, file=strPointsFile, quote=FALSE, row.names=FALSE, col.names=FALSE);
}


#replace with user's legends
for(index in 1:length(listLegendUsr)){
    if(nchar(listLegendUsr[index]) > 0){
      listLegendNotOrdered[index]=listLegendUsr[index];
      #add revision if needed
      if( index <= length(revision_stats)){
        ww_run_title = paste("WW Runs Test:", revision_stats[[index]]$ww_run, sep = " ");
        ac_test_title = paste("Auto-Corr Test: p=", revision_stats[[index]]$auto_cor_p, ",r=", revision_stats[[index]]$auto_cor_r, sep = " ");
        listLegendNotOrdered[index] = paste(listLegendNotOrdered[index],  " (");
        listLegendNotOrdered[index] = paste(listLegendNotOrdered[index], ww_run_title, " ");
        listLegendNotOrdered[index] = paste(listLegendNotOrdered[index], ac_test_title, " ");
        listLegendNotOrdered[index] = paste(listLegendNotOrdered[index],  ")");
      }
    }
}

#order legends
for(index in 1:length(listPlotOrderSeries)){
  listLegend[ listPlotOrderSeries[index] ]=listLegendNotOrdered[index];
}

# specify the output file
strPlotType = "#<plot_type>#";
if( "jpeg" == strPlotType ){
  jpeg(
    strPlotFile,            # output file name, with appropriate extension
    width=#<plot_width>#,	  # width of the display region, in specified units
    height=#<plot_height>#,	# height of the display region, in specified units
    res=#<plot_res>#,		    # resolution, in dots per inch
    units="#<plot_units>#",  # units for height and width
    pointsize = 12,
    quality = 100
  );
} else {
  bitmap(
    strPlotFile,            # output file name, with appropriate extension
    type="#<plot_type>#",    # type of bitmap
    width=#<plot_width>#,	  # width of the display region, in specified units
    height=#<plot_height>#,	# height of the display region, in specified units
    res=#<plot_res>#,		    # resolution, in dots per inch
    units="#<plot_units>#",  # units for height and width
    taa=4,                  # bits of anti-aliasing for graphics
    gaa=4                    # bits of anti-aliasing for text
  );
}

# specify the y-axis limits and labels
listY1Bounds = seriesMinMax(listSeries1, intNumSeries1+intNumSeries1Diff, boolLogY1, head(listPlotDisp, intNumSeries1+intNumSeries1Diff));
if( TRUE == boolLogY1 ){
  dblY1Min = 10^listY1Bounds$min;
  dblY1Max = 10^listY1Bounds$max;
  listY1axp = c(dblY1Min, dblY1Max, 3);
} else {
  if( 0 < length(listY1limUsr) ){
    dblY1Min = listY1limUsr[1];
    dblY1Max = listY1limUsr[2];
  } else {
    dblY1Min = listY1Bounds$min;
    dblY1Max = listY1Bounds$max;
  }
  listY1axp = c(dblY1Min, dblY1Max, 5);
}
listY1lim = c(dblY1Min, dblY1Max);

# specify plot window formatting
par(
  mar=#<mar>#,			# lines of margin in form c(bottom, left, top, right)
  mgp=#<mgp>#,			# margin line for axis title, axis labels and axis line in form c(title, labels, line)
  cex=#<cex>#,			# magnification for plot text
  las=2          # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
);

# change the order of series points depending on listIndyPlotVal
if( length(listIndyPlotVal) == length(listIndy) ){
  updatedList = c();
  for(index in 1:length(listIndyPlotVal)){
    newIndex = listIndyPlotVal[index]
    updatedList[newIndex] = listSeries1[[1]][index];
  }
  listSeries1[[1]] = updatedList;
}


# configuration variables for a horizontal series plot
if( FALSE == boolVertPlot ){
  listXSeries = listX;
  listY1Series = listSeries1[[1]];
  intXAxis = 1;
  intY1Axis = 2;
  intX2Axis = 3;
  intY2Axis = 4;
  intGridNx = 0;
  intGridNy = NULL;

  # configuration variables for a vertical plot
} else {
  listXSeries = listSeries1[[1]];
  listY1Series = listX;
  listTmp = listXlim;
  listXlim = listY1lim;
  listY1lim = listTmp;
  intXAxis = 2;
  intY1Axis = 1;
  intX2Axis = 4;
  intY2Axis = 3;
  intGridNx = NULL;
  intGridNy = 0;
}

# specify the plot formatting
plot(
  listXSeries,        # series x data
  listY1Series,        # series y1 data
  type="n",            # series line type - p: points, l: lines, o: overplotted points and lines,
  #   b or c: points joined by lines, s or S: stair steps, h: histogram, n: nothing
  xaxt="n",            # x-axis type - n: no axis, s: compatibility with l and t
  xaxs="r",            # x-axis style - r: regular, i: internal
  yaxt="n",            # y1-axis type - n: no axis, s: compatibility with l and t
  yaxs="r",            # x-axis style - r: regular, i: internal
  xlim=listXlim,      # x-axis limits in form c(x1,x2); x1 > x2 reverses axis
  ylim=listY1lim,      # y1-axis limits
  xlab="",            # x-axis label
  ylab="",            # y1-axis label
  lwd=1,              # line width
  cex.lab=1,          # relative axis label magnification
  cex.main=1,          # relative title magnification
  cex.sub=1,          # relative subtitle magnification
  fg="gray"
);

# set the plot window limits
if( TRUE == boolLogY1 ){
  par(ylog=TRUE, usr=c(par()$usr[1:2], listY1Bounds$min, listY1Bounds$max), yaxp=listY1axp);
} else {
  dblY1BufrPct = #<y1_bufr>#;
  dblY1Bufr = (dblY1Max - dblY1Min) * dblY1BufrPct;
  if( FALSE == boolVertPlot ){
    par(usr=c(par()$usr[1:2], dblY1Min - dblY1Bufr, dblY1Max + dblY1Bufr));
  } else {
    par(usr=c(dblY1Min - dblY1Bufr, dblY1Max + dblY1Bufr, par()$usr[3:4]));
  }
}


# plot title
mtext(
  "#<plot_title>#",        # label
  font=#<title_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
  las=0,                  # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  side=3,                  # axis of interest, 1: below, 2: left, 3: above and 4: right
  cex=#<title_size>#,		  # relative magnification
  padj=#<title_offset>#,	# axis label perpendicular location adjustment
  adj=#<title_align>#,	  # axis label parallel location adjustment
  line=1                  # margin line, starting at 0 counting outwards
);

# specify the x-axis
axis(
  intXAxis,                  # axis of interest, 1: below, 2: left, 3: above and 4: right
  at=listXForAxis,           # locations of tick marks
  labels=#<indy_label>#,	  # axis labels
  tick=TRUE,                # tick marks on/off
  tck=.01,                  # length of tick marks as a fraction of plot window
  las=#<xtlab_orient>#,	    # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  padj=#<xtlab_perp>#,	    # axis label perpendicular location adjustment
  hadj=#<xtlab_horiz>#,	    # axis label parallel location adjustment
  cex.axis=#<xtlab_size>#,  # relative axis label magnification
  col="gray"                # axis color
);

# x-axis label
mtext(
  "#<x_label>#",        # label
  font=#<xlab_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
  las=0,                # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  side=intXAxis,        # axis of interest, 1: below, 2: left, 3: above and 4: right
  cex=#<xlab_size>#,		# relative axis label magnification
  padj=#<xlab_offset>#,	# axis label perpendicular location adjustment
  adj=#<xlab_align>#,		# axis label parallel location adjustment
  line=1                # margin line, starting at 0 counting outwards
);

# specify the y-axis
axis(
  intY1Axis,                # axis of interest, 1: below, 2: left, 3: above and 4: right
  #at=NA,					          # locations of tick marks
  labels=TRUE,              # tick labels on/off
  tick=TRUE,                # tick marks on/off
  tck=.01,                  # length of tick marks as a fraction of plot window
  las=#<ytlab_orient>#,	    # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  padj=#<ytlab_perp>#,	    # axis label perpendicular location adjustment
  hadj=#<ytlab_horiz>#,	    # axis label parallel location adjustment
  cex.axis=#<ytlab_size>#,  # relative axis label magnification
  col="gray"                # axis color
);

# y-axis label
mtext(
  "#<y1_label>#",        # label
  font=#<ylab_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
  las=0,                # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  side=intY1Axis,        # axis of interest, 1: below, 2: left, 3: above and 4: right
  cex=#<ylab_size>#,		# relative axis label magnification
  padj=#<ylab_offset>#,	# axis label perpendicular location adjustment
  adj=#<ylab_align>#,		# axis label parallel location adjustment
  line=1                # margin line, starting at 0 counting outwards
);

# add grid lines to the plot, if requested
if( TRUE == boolGridOn ){
  grid(
    lty=#<grid_lty>#,		  # line type - 0: blank, 1: solid, 2: dashed, 3: dotted, 4: dotdash, 5: longdash, 6: twodash
    col="#<grid_col>#",    # line color
    lwd=#<grid_lwd>#,		  # line width
    nx=intGridNx,          # number of cells in x direction, NULL for default
    ny=intGridNy          # number of cells in y direction, NULL for default
  );

  # calculate the grid line locations
  listXGrid = #<grid_x>#;
  intXtlabDecim = #<xtlab_decim>#;
  if( 0 < intXtlabDecim ){
    listXGrid = listXGrid[seq(from=1, to=length(listX), by=intXtlabDecim)];
  }

  if( FALSE == boolVertPlot ){
    abline(
      v=listXGrid,            # list of positions for the gridlines
      lty=#<grid_lty>#,		    # line type - 0: blank, 1: solid, 2: dashed, 3: dotted, 4: dotdash, 5: longdash, 6: twodash
      col="#<grid_col>#",      # line color
      lwd=#<grid_lwd>#,		    # line width
      cex=1                    # line magnification
    );
  } else {
    abline(
      h=listXGrid,          # list of positions for the gridlines
      lty=#<grid_lty>#,		  # line type - 0: blank, 1: solid, 2: dashed, 3: dotted, 4: dotdash, 5: longdash, 6: twodash
      col="#<grid_col>#",    # line color
      lwd=#<grid_lwd>#,		  # line width
      cex=1                  # line magnification
    );
  }
}

# add the number of stats at each independent axis tick, if requested
if( TRUE == boolShowNStats ){
  axis(
    intX2Axis,                # axis of interest, 1: below, 2: left, 3: above and 4: right
    at=listX,                  # locations of tick marks
    labels=listNStats,        # axis labels
    tick=TRUE,                # tick marks on/off
    tck=.01,                  # length of tick marks as a fraction of plot window
    las=#<x2tlab_orient>#,	  # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    padj=#<x2tlab_perp>#,	    # axis label perpendicular location adjustment
    hadj=#<x2tlab_horiz>#,	  # axis label parallel location adjustment
    cex.axis=#<x2tlab_size>#, # relative axis label magnification
    col="gray"                # axis color
  );

  mtext(
    "NStats",                # label
    las=0,                  # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    side=intX2Axis,          # axis of interest, 1: below, 2: left, 3: above and 4: right
    font=#<x2lab_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
    cex=#<x2lab_size>#,		  # relative axis label magnification
    padj=#<x2lab_offset>#,	# axis label perpendicular location adjustment
    adj=#<x2lab_align>#,	  # axis label parallel location adjustment
    line=1                  # margin line, starting at 0 counting outwards
  );
}




# build the x-adjustment increments, if requested
dblAdjScale = (listX[length(listX)] - listX[1]) / 150;


# if log scale is on for either axis, disable sync_axes
if( TRUE == boolLogY1 | TRUE == boolLogY2 ){ boolSyncAxes = FALSE; }

# plot the y2-axis series first, so that they lie underneath the y1-axis series
listY1Usr = par()$usr;
par(ylog=FALSE);

if( 0 < length(listDep2Plot) ){

  intNumStag2 = 0;
  if( 0 < ( intNumSeries2 ) ){
    intNumStag2 = ( intNumSeries2 + intNumSeries2Diff ) - sum(!listPlotDispSeries2);
  }

  listX2Stag = rep(0, intNumStag2 + 1);
  if( TRUE == boolIndy2Stagger ){
    listX2Stag = seq( -(intNumStag2/2)*dblAdjScale, (intNumStag2/2)*dblAdjScale, length=intNumStag2 + 1 ) + ( dblAdjScale/2 );
  }

  # adjust the y2 bounds, if requested
  if( FALSE == boolSyncAxes ){

    # determine the axis bounds, depending on the y2_log setting
    listY2Bounds = seriesMinMax(listSeries2, intNumSeries2 +intNumSeries2Diff , boolLogY2, tail(listPlotDisp, intNumSeries2 +intNumSeries2Diff));
    if( TRUE == boolLogY2 ){
      dblY2Min = 10^listY2Bounds$min;
      dblY2Max = 10^listY2Bounds$max;
      listY2axp = c(dblY2Min, dblY2Max,  3);
    } else {
      if( 0 < length(listY2limUsr) ){
        dblY2Min = listY2limUsr[1];
        dblY2Max = listY2limUsr[2];
      } else {
        dblY2Min = listY2Bounds$min;
        dblY2Max = listY2Bounds$max;
      }
      listY2axp = c(dblY2Min, dblY2Max, 5);
    }

  } else {
    listY2axp = listY1axp;
    boolLogY2 = boolLogY1;
    listY2Bounds = listY1Bounds;
    dblY2Min = dblY1Min;
    dblY2Max = dblY1Max;
  }

  # set the plot window limits
  if( TRUE == boolLogY2 ){
    par(new=TRUE, ylog=TRUE, usr=c(par()$usr[1:2], listY2Bounds$min, listY2Bounds$max), yaxp=listY2axp, xaxs="r");
  } else {
    dblY2BufrPct = #<y2_bufr>#;
    dblY2Bufr = (dblY2Max - dblY2Min) * dblY2BufrPct;

    if( FALSE == boolVertPlot){
      listY2Usr = c(par()$usr[1:2], dblY2Min - dblY2Bufr, dblY2Max + dblY2Bufr);
    }else{
      listY2Usr = c( dblY2Min - dblY2Bufr, dblY2Max + dblY2Bufr,par()$usr[3:4]);
    }
    par(new=TRUE, usr=listY2Usr, xaxs="r");
  }

  # add the y2 axis
  axis(
    intY2Axis,                # axis of interest, 1: below, 2: left, 3: above and 4: right
    #at=NA,					          # locations of tick marks
    labels=TRUE,              # tick labels on/off
    tick=TRUE,                # tick marks on/off
    tck=.01,                  # length of tick marks as a fraction of plot window
    las=#<y2tlab_orient>#,	  # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    padj=#<y2tlab_perp>#,	    # axis label perpendicular location adjustment
    hadj=#<y2tlab_horiz>#,	  # axis label parallel location adjustment
    cex.axis=#<y2tlab_size>#, # relative axis label magnification
    col="gray"                # axis color
  );

  # plot each series on the second dependent axis with the specified formatting
  for(i in 1:(intNumSeries2 + intNumSeries2Diff)){
    # if the current series is not displayed, continue to the next
    if( !listPlotDispSeries2[i] ){
      next;
    }
    intStagIndex = listPlotOrderSeries2Part[i];


    # slice the series constituents from the series list
    listData  = listSeries2[[3*(intStagIndex-1) + 1]];
    listDataLo  = listSeries2[[3*(intStagIndex-1) + 2]];
    listDataUp  = listSeries2[[3*(intStagIndex-1) + 3]];
    listXAdj  = listX + listX2Stag[intStagIndex];

    # remove the NAs from the x and y lists
    listDataInd  = !( is.na(listData) );
    if( listConSeries2[i] != 0 ){
      listXAdj  = listXAdj[listDataInd];
      listData  = listData[listDataInd];
    }

    # if the plot is a vertical profile, swap the series coordinates
    if( TRUE == boolVertPlot ){ listTmp = listXAdj; listXAdj = listData; listData = listTmp; }

    # plot the series line
    lines(
      listXAdj,                      # x coordinates
      listData,                      # y coordinates
      type=listTypeSeries2[intStagIndex],      # series line type - p: points, l: lines, o: overplotted points and lines,
      #   b or c: points joined by lines, s or S: stair steps, h: histogram, n: nothing
      pch=listPchSeries2[intStagIndex],        # point symbol - see example(points)
      font=5,                        # 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
      lty=listLtySeries2[intStagIndex],        # line type - 0: blank, 1: solid, 2: dashed, 3: dotted, 4: dotdash, 5: longdash, 6: twodash
      col=listColorsSeries2[intStagIndex],      # line color
      lend=1,
      cex=1,                        # line magnification
      lwd=listLwdSeries2[intStagIndex]          # line width
    );

    # add arrows to the line, if requested
    if( "none" != listPlotCISeries2[intStagIndex] ) {
      listDataInd = listDataInd & 0 < abs(listDataUp - listDataLo);
      if( 0 < sum(listDataInd) ){
        listXAdj  = listX + listX2Stag[intStagIndex];
        listXAdj  = listXAdj[listDataInd];
        listDataLo  = listDataLo[listDataInd];
        listDataUp  = listDataUp[listDataInd];

        listXFr    = listXAdj;
        listXTo  = listXAdj;
        listYFr  = listDataLo;
        listYTo  = listDataUp;

        # if the plot is a vertical profile, swap the series coordinates
        if( TRUE == boolVertPlot ){
          listTmp = listXFr; listXFr = listYFr; listYFr = listTmp;
          listTmp = listXTo; listXTo = listYTo; listYTo = listTmp;
        }
        for(ind in 1: length(listXAdj)) {
          if(listShowSignifSeries2[intStagIndex] == FALSE){
            lwd_current = listLwdSeries2[intStagIndex];
          }else{
            if(TRUE ==boolVertPlot){
              if( listXFr[ind] < 0 && listXTo[ind] > 0){
                lwd_current = listLwdSeries2[intStagIndex];
              }else{
                lwd_current = listLwdSeries2[intStagIndex] + 3;
              }

            }else{
              if(  listYFr[ind] < 0  && listYTo[ind] > 0){
                lwd_current = listLwdSeries2[intStagIndex];
              }else{
                lwd_current = listLwdSeries2[intStagIndex] + 3;
              }
            }
          }

          # draw the arrows
          arrows(
            listXFr[ind],                      # x coordinate from which to draw
            listYFr[ind],                      # y coordinate from which to draw
            listXTo[ind],                      # x coordinate to which to draw
            listYTo[ind],                      # y coordinate to which to draw
            length=.02,                    # length of the edges of the arrow head (in inches)
            angle=90,                      # angle from the shaft of the arrow to the edge of the arrow head
            code=3,                        # arrow type - 1: up, 2: down and 3: both
            lwd=lwd_current,              # line width
            col=listColorsSeries2[intStagIndex],      # line color
            ljoin=1,                      # line join style - 0: round, 1: mitre and 2: bevel
            lmitre=1,                      # line mitre limit, range 1-10
            lend=2                        # line end style - 0: round, 1: butt and 2: square
          );
        }
      }
    }

  } # end: for(i in 1:intNumSeries2)

  # y2 axis label
  mtext(
    "#<y2_label>#",          # label
    font=#<y2lab_weight>#,	# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
    las=0,                  # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
    side=intY2Axis,          # axis of interest, 1: below, 2: left, 3: above and 4: right
    cex=#<y2lab_size>#,		  # relative axis label magnification
    padj=#<y2lab_offset>#,	# axis label perpendicular location adjustment
    adj=#<y2lab_align>#,	  # axis label parallel location adjustment
    line=1                  # margin line, starting at 0 counting outwards
  );

} # end: if( 0 < length(listDep2Plot) )

# restore the plot window limits for y1
if( TRUE == boolLogY1 ){
  par(new=TRUE, ylog=TRUE, usr=c(par()$usr[1:2], listY1Bounds$min, listY1Bounds$max));
} else {
  par(new=TRUE, ylog=FALSE, usr=listY1Usr, xaxs="r");
}

# build the x-adjustment increments, if requested
intNumStag1 = intNumSeries1 + intNumSeries1Diff;

listX1Stag = rep(0, intNumStag1 + 1);
if( TRUE == boolIndy1Stagger ){
  listX1Stag = seq( -(intNumStag1/2)*dblAdjScale, (intNumStag1/2)*dblAdjScale, length=intNumStag1 + 1 ) + ( dblAdjScale/2 );
}

# plot the y1-axis series
for(i in 1:(intNumSeries1+ intNumSeries1Diff)){

  # if the current series is not displayed, continue to the next
  if( !listPlotDispSeries1[i] ){
    next;
  }

  #intStagIndex = listPlotOrderSeries1Part[i];
  intStagIndex = i

  # slice the series constituents from the series list
  listData  = listSeries1[[3*(intStagIndex-1) + 1]];
  listDataLo  = listSeries1[[3*(intStagIndex-1) + 2]];
  listDataUp  = listSeries1[[3*(intStagIndex-1) + 3]];
  listXAdj  = listX + listX1Stag[intStagIndex];



  # remove the NAs from the x and y lists
  listDataInd  = !( is.na(listData) );
  if( listConSeries1[intStagIndex] != 0 ){
    listXAdj  = listXAdj[listDataInd];
    listData  = listData[listDataInd];
  }

  # if the plot is a vertical profile, swap the series coordinates
  if( TRUE == boolVertPlot ){ listTmp = listXAdj; listXAdj = listData; listData = listTmp; }

  # plot the series line
  lines(
    listXAdj,                      # x coordinates
    listData,                      # y coordinates
    type=listTypeSeries1[intStagIndex],      # series line type - p: points, l: lines, o: overplotted points and lines,
    #   b or c: points joined by lines, s or S: stair steps, h: histogram, n: nothing
    pch=listPchSeries1[intStagIndex],        # point symbol - see example(points)
    font=5,                        # 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
    lty=listLtySeries1[intStagIndex],        # line type - 0: blank, 1: solid, 2: dashed, 3: dotted, 4: dotdash, 5: longdash, 6: twodash
    col=listColorsSeries1[intStagIndex],      # line color
    cex=1,                        # line magnification
    lwd=listLwdSeries1[intStagIndex]          # line width
  );

  # add arrows to the line, if requested
  if( "none" != listPlotCISeries1[intStagIndex] ) {
    listDataInd = listDataInd & 0 < abs(listDataUp - listDataLo);
    if( 0 < sum(listDataInd) ){
      listXAdj  = listX + listX1Stag[intStagIndex];
      listXAdj  = listXAdj[listDataInd];
      listDataLo  = listDataLo[listDataInd];
      listDataUp  = listDataUp[listDataInd];

      listXFr    = listXAdj;
      listXTo  = listXAdj;
      listYFr  = listDataLo;
      listYTo  = listDataUp;

      # if the plot is a vertical profile, swap the series coordinates
      if( TRUE == boolVertPlot ){
        listTmp = listXFr; listXFr = listYFr; listYFr = listTmp;
        listTmp = listXTo; listXTo = listYTo; listYTo = listTmp;
      }

      for(ind in 1: length( listXAdj) ){
        if(listShowSignifSeries1[i] == FALSE){
          lwd_current = listLwdSeries1[intStagIndex];
        }else{
          if(TRUE ==boolVertPlot){
            if( listXFr[ind] < 0 && listXTo[ind] > 0){
              lwd_current = listLwdSeries1[intStagIndex];
            }else{
              lwd_current = listLwdSeries1[intStagIndex] + 3;
            }
          }else{
            if(  listYFr[ind] < 0  && listYTo[ind] > 0){
              lwd_current = listLwdSeries1[intStagIndex];
            }else{
              lwd_current = listLwdSeries1[intStagIndex] + 3;
            }
          }
        }

        arrows(
          listXFr[ind],                      # x coordinate from which to draw
          listYFr[ind],                      # y coordinate from which to draw
          listXTo[ind],                      # x coordinate to which to draw
          listYTo[ind],                      # y coordinate to which to draw
          length=.02,                    # length of the edges of the arrow head (in inches)
          angle=90,                      # angle from the shaft of the arrow to the edge of the arrow head
          code=3,                        # arrow type - 1: up, 2: down and 3: both
          lwd=lwd_current,              # line width
          col=listColorsSeries1[intStagIndex],      # line color
          ljoin=1,                      # line join style - 0: round, 1: mitre and 2: bevel
          lmitre=1,                      # line mitre limit, range 1-10
          lend=2                        # line end style - 0: round, 1: butt and 2: square
        );
      }
    }
  }

} # end: for(i in 1:intNumSeries1)

listLwdLeg = listLwdOrdered;
listLwdLeg[listLwdLeg > 3] = 3;

# mask the hidden elements from the legend and color list
listLegendDisp = listLegend[listPlotDispOrdered];
listColorsDisp = listColorsOrdered[listPlotDispOrdered];
listLtyDisp    = listLtyOrdered[listPlotDispOrdered];
listPchDisp    = listPchOrdered[listPlotDispOrdered];
listTypeDisp = listTypeOrdered[listPlotDispOrdered];


#display only a symbol for line type 'p'
for(indType in 1:length(listTypeDisp) ){
  if (listTypeDisp[indType] == 'p'){
    listLtyDisp[indType] = NaN;
    listLtyDisp[indType] = NaN;
  }
}

# add the legend
legend(
  x="bottom",                  # x coordinate of legend
  listLegendDisp,              # vector of legend labels
  col=listColorsDisp,          # vector of point and line colors
  lty=listLtyDisp,            # vector of line types
  lwd=listLwdLeg,              # vector of line widths
  pch=listPchDisp,            # vector of point symbols
  merge=FALSE,                # merge points and lines
  cex=#<legend_size>#,			  # relative magnification
  bty="#<legend_box>#",        # legend box type - o: box, n: none
  #bg="#EEEEEEFF",				    # background color
  #box.lty=,						      # legend box line type
  #box.lwd=,						      # legend box line width
  #horiz=FALSE,					      # horizontal configuration
  adj=0,                      # string adjustment for text
  xpd=TRUE,                    # clipping - FALSE: plot region, TRUE: figure region, NA: device region
  ncol=#<legend_ncol>#,			  # number of columns in legend
  #agginset=c(0, -.25),			  # inset distance from margin
  inset=#<legend_inset>#,			# inset distance from margin
  x.intersp=1,                # horizontal character spacing factor
  y.intersp=.8                # vertical character spacing factor
);

# plot caption
mtext(
  "#<plot_caption>#",          # caption
  font=#<caption_weight>#,		# 1: plain text, 2: bold, 3: italic, 4: bold italic and 5: symbol
  col="#<caption_col>#",      # font color
  las=0,                      # axis label orientation - 0: parallel to axis, 1: horiz, 2: perp to axis, 3: vert
  side=1,                      # axis of interest, 1: below, 2: left, 3: above and 4: right
  cex=#<caption_size>#,			  # relative magnification
  padj=#<caption_offset>#,		# axis perpendicular location adjustment
  adj=#<caption_align>#,			# axis parallel location adjustment
  line=1                      # margin line, starting at 0 counting outwards
);

#<plot_cmd>#

invisible(dev.off());



